#编程基础  #c语言中文网 #c语言教程 

# 12.1 C语言中的文件是什么？

- 在操作系统中，为了统一对各种硬件的操作，简化接口，**不同的硬件设备**也都被看成一个文件。
	- 通常==把显示器称为标准输出文件==，printf 就是向这个文件输出数据；
	- 通常==把键盘称为标准输入文件==，scanf 就是从这个文件读取数据。

常见硬件设备所对应的文件：

|文件|硬件设备|
|---|---|
|stdin|标准输入文件，一般指键盘；scanf()、getchar() 等函数默认从 stdin 获取输入。|
|stdout|标准输出文件，一般指显示器；printf()、putchar() 等函数默认向 stdout 输出数据。|
|stderr|标准错误文件，一般指显示器；perror() 等函数默认向 stderr 输出数据（后续会讲到）。|
|stdprn|标准打印文件，一般指打印机。|

- **操作文件的正确流程为：打开文件 --> 读写文件 --> 关闭文件**
	- **打开文件：**
		- 获取文件的有关信息，例如文件名、文件状态、当前读写位置等
		- 保存到一个FILE类型的结构体变量中
	- **关闭文件：**
		- 断开与文件之间的联系
		- 释放结构体变量
		- 禁止再对该文件进行操作

## 文件流

- 数据在文件和内存之间传递的过程叫做文件流
	- 输入流：数据从文件复制到内存的过程
	- 输出流：数据从内存保存到文件的过程

- **数据源：** 文件、数据库、网络、键盘、...
- 数据传递到内存也就是保存到C语言的变量（例如整数、字符串、数组、缓冲区等）
	- 数据流 Data Stream：数据在数据源和程序（内存）之间传递的过程
	- **输入流(Input Stream)**
		- 数据从**数据源**到**程序（内存）** 的过程
	- **输出流(Output Stream)**
		- 数据从**程序（内存）** 到**数据源**的过程

- 输入输出（Input output，IO）是指程序（内存）与外部设备（键盘、显示器、磁盘、其他计算机等）进行交互的操作

# 12.2 C语言fopen函数的用法，C语言打开文件详解

在C语言中，操作文件之前必须先打开文件；所谓“打开文件”，就是让程序和文件建立连接的过程。

>标准输入文件 stdin（表示键盘）、标准输出文件 stdout（表示显示器）、标准错误文件 stderr（表示显示器）是由系统打开的，可直接使用。

使用 <stdio.h> 头文件中的 fopen() 函数即可打开文件，它的用法为：

```c
FILE *fopen(char *filename, char *mode);
```

`filename`为文件名（包括文件路径），`mode`为打开方式，它们都是字符串。

## `fopen()` 函数的返回值

- `fopen()` 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，然后将该变量的地址返回。
	- FILE 是 <stdio.h> 头文件中的一个结构体，它专门用来保存文件信息

如果希望接收 fopen() 的返回值，就需要定义一个 FILE 类型的[指针](https://c.biancheng.net/c/80/)。例如：  

```c
FILE *fp = fopen("demo.txt", "r");
```

表示以“只读”方式打开当前目录下的 demo.txt 文件，并使 fp 指向该文件，这样就可以通过 fp 来操作 demo.txt 了。fp 通常被称为文件指针。

**判断文件是否打开成功**

打开文件出错时，fopen() 将返回一个空指针，也就是 NULL，我们可以利用这一点来判断文件是否打开成功，请看下面的代码：

```c
FILE *fp;
if( (fp=fopen("D:\\demo.txt","rb")) == NULL ){
    printf("Fail to open file!\n");
    exit(0);  //退出程序（结束程序）
}
```

- **在打开文件时一定要判断文件是否打开成功**

## fopen() 函数的打开方式

- 按照数据的存储方式
	- 二进制文件
	- 文本文件

- 控制读写权限的字符串（必须指明）

| 打开方式 | 说明                                                                                                                                                                                                       |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| "r"      | 以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。                                                                                                                                 |
| "w"      | 以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。                                                                           |
| "a"      | 以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。                                                                           |
| "r+"     | 以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。==文件必须存在==，否则打开失败。                                                                                                           |
| "w+"     | 以“写入/更新”方式打开文件，相当于`w`和`r+`叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
| "a+"     | 以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。     |

- 控制读写方式的字符串（可以不写）

| 打开方式 | 说明                              |
| -------- | --------------------------------- |
| "t"      | 文本文件。如果不写，默认为`"t"`。 |
| "b"      | 二进制文件。                      |
 
- 必须要将**读写方式放在读写权限的中间或者尾部**

## 关闭文件

- **文件一旦使用完毕，应该用 fclose() 函数把文件关闭，以释放相关资源，避免数据丢失**

fclose() 的用法为：

```c
int fclose(FILE *fp);
```

fp 为文件指针。例如：

```c
fclose(fp);
```

文件正常关闭时，fclose() 的返回值为0，如果返回非零值则表示有错误发生。

# 12.3 文本文件和二进制文件到底有什么区别？

## 文本文件和二进制文件的区别

- 文本文件通常用来保存肉眼可见的字符，比如`.txt`文件、`.c`文件、`.dat`文件等
	- 用文本编辑器打开这些文件，我们能够顺利看懂文件的内容
	- **看得懂的原因**：
		- 因为文本文件中采用的是 **ASCII、UTF-8、GBK 等字符编码**，文本编辑器可以识别出这些编码格式，并**将编码值转换成字符**展示出来
- 二进制文件通常用来保存视频、图片、程序等不可阅读的内容
	- 如果用文本编辑器打开，会出现一堆乱码
- 从物理上讲，二进制文件和字符文件并没有什么区别，它们==都是以二进制的形式保存在磁盘上的数据==。
- 不同类型的文件有不同的编码格式，必须使用对应的程序（软件）才能正确解析，否则就是一堆乱码，或者无法使用

## `fopen()` 中的文本方式和二进制方式

> 在C语言中，二进制方式很简单
> -> 读取文件时，会**原封不动的读出文件的全部內容**
> -> 写入数据时，也是**把缓冲区中的內容原封不动的写到文件**中。

- 文本方式和二进制方式并没有本质上的区别，只是==对于换行符的处理==不同

- C语言中`\n`为换行符
	- 类UNIX/Linux系统同样
	- **Windows下不同**
		- 以`\r\n`为文本文件的换行符

- **Windows系统中**
	- **以文本方式打开文件**
		- 读取文件：将所有的`\r\n`都转换成一个`\n`字符
		- 写入文件：将`\n`转换成`\r\n`写入
		- 即，Windows打开文本文件会对文件中的换行符进行添加/删除`\r`的操作
	- 因此，如果用文本方式打开二进制文件进行读写，读写的内容会出现问题

- **总结：**
	- ==对于 Windows 平台==
		- 用`"t"`来打开文本文件
		- 用`"b"`来打开二进制文件
	- 对于 Linux 平台
		- 使用`"t"`还是`"b"`都无所谓
		- 默认是`"t"`，所以可以不写

# 12.4 C语言`fgetc`和`fputc`函数用法详解（以字符形式读写文件）

- **以字符形式读写文件**
	- 此时，每次只能向文件中**读取一个字符**或者**写入一个字符**
	- 函数分别为：`fgetc()`和`fputc()`

## 字符读取函数 fgetc

fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符。fgetc() 的用法为：

```c
int fgetc (FILE *fp);
```

fp 为文件[指针](https://c.biancheng.net/c/80/)。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回`EOF`。

EOF 是 end of file 的缩写，表示文件末尾，是在 stdio.h 中定义的宏，它的值是一个负数，往往是 -1。fgetc() 的==返回值类型之所以为 int，就是为了容纳这个负数（char不能是负数）==。

- **注意**：这个**文件内部的位置指针**与**C语言中的指针**不是一回事
	- **位置指针**：只是一个表示了文本读写到的位置，即第几个字节的地方，并不表示地址
	- 系统自动设置，对用户隐藏

- **EOF的说明**
	- 判断读取完毕和读取出错
	- feof() 函数用来**判断文件内部指针是否指向了文件末尾**，它的原型是：
		 ```c
		int feof ( FILE * fp );
		```
		- 当指向文件末尾时返回非零值，否则返回零值 
	- ferror() 函数用来**判断文件操作是否出错**，它的原型是：
		```c
		int ferror ( FILE *fp );
		```
		- 出错时返回非零值，否则返回零值

## 字符写入函数 fputc

fputc 是 file output char 的所以，意思是==向指定的文件中写入一个字符==。fputc() 的用法为：

```c
int fputc ( int ch, FILE *fp );
```

ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回 EOF，返回值==类型为 int 也是为了容纳这个负数==。

# 12.5 C语言fgets和fputs函数的用法详解（以字符串的形式读写文件）

## 读字符串函数 fgets

- fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中，它的用法为：

	```c
	char *fgets ( char *str, int n, FILE *fp );
	```
	
	- str 为字符数组，n 为要读取的字符数目，fp 为文件[指针](https://c.biancheng.net/c/80/)。
	- 返回值：
		- ==读取成功时返回字符数组首地址，也即 str==；
		- 读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL.
	- **fgets() 最多只能读取一行数据，不能跨行**
		- 遇到换行或者到文件末尾就会结束读取
		- 但是**fgets()可以读取到换行符**，而**gets()会忽略换行符**

- **读取到的字符串会在末尾自动添加 '\0'，n 个字符也包括 '\0'**

## 写字符串函数 fputs

- fputs() 函数用来向指定的文件写入一个字符串，它的用法为：
	
	```c
	int fputs( char *str, FILE *fp );
	```
	
	- str 为要写入的字符串，fp 为文件指针。写入成功返回非负数，失败返回 EOF。

# 12.6 C语言fread和fwrite的用法详解（以数据块的形式读写文件）

- fgets() 每次最多从文件中读取一行内容

为了能够对多行内容进行操作

## fread()
- 从指定文件中读取**块数据**。即若干个字节的数据，字符、字符串、多行数据等
- `size_t fread(void *ptr, size_t size, size_t count, FILE *fp);`

## fwrite()
- 向指定文件中写入**块数据**
- `size_t fwrite(void *ptr, size_t size, size_t count, FILE *fp);`

## 参数说明
- ptr：内存区块的指针
	- fread中ptr存放读取到的数据
	- fwrite中ptr存放要写入的数据
- size：每个数据块的字节数
- count：要读写的数据块的块数
- fp：文件指针
- **理论上，每次读写 `size*count` 个字节的数据**
- `size_t` 是 `stdio.h` 和 `stdlib.h` 头文件中使用typedef定义的数据类型，表示无符号数，即非负数

## 返回值
- 成功读写的块数，即count
- 返回值 < count：
	- fwrite()：**一定发生了写入错误**，使用 **ferror()** 函数检测
	- fread()：
		- 可能读取到了文件尾
		- 可能发生错误
		- 需要用 **ferror()** 和 **feof()** 检测

- 【示例】键盘输入两个学生数据，写入文件，再读取数据显示在屏幕

```c
#include <stdio.h>

#define N 2

struct stu{
	char name[10];
	int num;
	int age;
	float score;
} boya[N], boyb[N], *pa, *pb;

int main(){
	FILE *fp;
	int i;
	pa = boya;
	pb = boyb;

	char *path = "demo.txt";

	if ((fp = fopen(path, "wb+")) == NULL){
		puts("Fail to open file!");
		exit(0);
	}

	printf("Input data:\n");
	for (i=0; i<N; i++,pa++){
		scanf("%s %d %d %f", pa->name, &pa->num, &pa->age, &pa->score);
	}
	
	fwrite(boya, sizeof(struct stu), N, fp);
	rewind(fp);
	fread(boyb, sizeof(struct stu), N, fp);

	for(i=0; i<N; i++,pb++){
		printf("%s %d %d %f\n", pb->name, pb->num, pb->age, pb->score);
	}

	fclose();
	return 0;
}
```

- 运行结果：

```c
Input data:
Tom 2 15 90.5↙
Hua 1 14 99↙

Output data:
>> Tom  2  15  90.500000
>> Hua  1  14  99.000000
```

# 12.7 C语言fscanf和fprintf函数的用法详解（格式化读写文件）

- 与 scanf() 和 printf() 功能相似
- 但是，
	- **fscanf() 和 fprintf() 的读写对象**不是键盘和显示器，而是**磁盘文件**

## fscanf

```c
int fscanf ( FILE *fp, char * format, ... );
```

- fprintf() 返回成功写入的字符的个数，失败则返回负数
## fprintf

```c
int fprintf ( FILE *fp, char * format, ... );
```

- fscanf() 返回参数列表中被成功赋值的参数个数

- [【示例】用fscanf和fprintf来对学生信息读写](fscan_fprintf.c)

# 12.8 C语言rewind和fseek函数的用法详解（随机读写文件）

实现随机读写的关键是要**按要求移动位置指针**，这称为文件的定位

## rewind

- 将位置指针移动到文件开头，前面已经多次使用过，它的原型为：

```c
void rewind ( FILE *fp );
```

## fseek

- 将位置指针移动到任意位置，它的原型为：

```c
int fseek ( FILE *fp, long offset, int origin );
```

参数说明：

1) fp 为**文件指针**，也就是被移动的文件。  
  
2) offset 为**偏移量**，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。  
  
3) origin 为**起始位置**，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为文件开头、当前位置和文件末尾，每个位置都用对应的常量来表示：

|起始点|常量名|常量值|
|---|---|---|
|文件开头|SEEK_SET|0|
|当前位置|SEEK_CUR|1|
|文件末尾|SEEK_END|2|

**fseek() 一般用于二进制文件，在文本文件中由于要进行转换，计算的位置有时会出错**

[【随机读写示例】从键盘输入三个学生信息，保存到文件中，读取第二个学生的信息](obsidian://open?vault=ComputerGraphics&file=001-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2FC%2B%2B%2FC%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91%2FC%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%2Fnotes%2Fc-files%2F12%2Frewind_fseek.c)

# 12.9 C语言实现文件复制功能(包括文本文件和二进制文件)

实现文件复制的**主要思路**是：
- 开辟一个缓冲区，
- 不断从原文件中读取内容到缓冲区，
- 每读取完一次就将缓冲区中的内容写入到新建的文件，直到把原文件的内容读取完

两个关键问题：
1) 缓冲区需要多大？
	- 目前大部分磁盘的扇区都是4K对齐的，如果读写的数据不是4K的整数倍，就会跨扇区读取，降低效率，所以我们**开辟4K的缓冲区**
2) 缓冲区中的数据是没有结束标志的，如果缓冲区填充不满，如何确定写入的字节数？
	- 最好的办法就是**每次读取都能返回读取到的字节数**。

- 利用fread()函数，其定义为：

```c
size_t fread ( void *ptr, size_t size, size_t count, FILE *fp );
```

返回值：
- 成功读写的块数（小于等于count）
- 当size=1，则返回的就是读取的字节数

**注意**：
- fopen()一定要以二进制形式打开文件，不能以文本形式打开，否则会对文件进行一些处理

[文件复制的代码实现](obsidian://open?vault=ComputerGraphics&file=001-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2FC%2B%2B%2FC%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E7%BD%91%2FC%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%2Fnotes%2Fc-files%2F12%2FcopytFile.c)

# 12.10 C语言FILE结构体以及缓冲区深入探讨

在C语言中，用一个指针变量指向一个文件，这个指针称为文件指针

定义文件指针的一般形式为：

```c
FILE  *fp;
```

这里的FILE，实际上是在stdio.h中定义的一个结构体，该结构体中含有文件名、文件状态和文件当前位置等信息，fopen 返回的就是FILE类型的指针。

注意：==FILE是文件缓冲区的结构==，==fp也是指向文件缓冲区的指针==。

不同编译器 stdio.h 头文件中对 FILE 的定义略有差异，这里以标准C举例说明：

```c
1. typedef struct _iobuf {
2.     int cnt;  // 剩余的字符，如果是输入缓冲区，那么就表示缓冲区中还有多少个字符未被读取
3.     char *ptr;  // 下一个要被读取的字符的地址
4.     char *base;  // 缓冲区基地址
5.     int flag;  // 读写状态标志位
6.     int fd;  // 文件描述符
7.     // 其他成员
8. } FILE;
```

- 当缓冲区中没有任何数据的时候要将 ptr 这个值进行一下刷新，使其指向缓冲区的基地址
- 需要敲一下回车键才能够将这个字符串送入到缓冲区中。**换行符`\n`也会被存储在缓冲区中**

**缓冲区的刷新就是将指针 ptr 变为缓冲区的基地址 ，同时 cnt 的值变为0** ，因为缓冲区刷新后里面是没有数据的！

# 12.11 C语言获取文件大小（长度）

C语言没有提供获取文件大小的函数，要想实现该功能，必须自己编写函数。

## ftell()函数

ftell() 函数用来获取**文件内部指针（位置指针）距离文件开头的字节数**，它的原型为：

```c
long int ftell ( FILE * fp );
```

注意：fp 要**以二进制方式打开**，如果以文本方式打开，函数的返回值可能没有意义。

实现方法：
- 先使用 fseek() 将文件内部指针定位到文件末尾，再使用 ftell() 返回内部指针距离文件开头的字节数，这个返回值就等于文件的大小

```c
long fsize(FILE *fp){
	fseek(fp, 0, SEEK_END);
	return ftel(fp);
}
```

- 存在问题：
	- 由于这种方式移动了文件内部指针，会导致接下来文件操作错误
	- 所以需要对文件内部指针进行恢复

```c
long fsize(FILE *fp){
	long n;
	
	fpos_t fpos; // cur position
	fgetpos(fp, &fpos); // get current position
	
	fseek(fp, 0, SEEK_END);
	n = ftell(fp);
	
	fsetpos(fp, &fpos); // recover pre prosition
	
	return n;
}
```

- fpos_t 是在 stdio.h 中定义的结构体，用来保存文件的内部指针。
- fgetpos() 用来获取文件内部指针，fsetpos() 用来设置文件内部指针。

# 12.12 C语言插入、删除、更改文件内容

平时的文件都是按照从头到尾的顺序依次存储在磁盘，为**顺序文件**

这种存储结构使得它能够高效读取内容，**但不能随意插入、删除和修改内容**
- 例如在文件开头插入100个字节的数据，那么原来文件的所有内容都要向后移动100个字节，这不仅是非常低效的操作，而且还可能覆盖其他文件。

**插入数据的思路**：假设原来文件的大小为 1000 字节，现在要求在500字节处插入用户输入的字符串
1) 创建一个临时文件temp file，将后面500字节的内容复制到temp file；
2) 将原文件中内部指针调整到500字节处，写入字符串；
3) 将temp file的内容写入源文件

删除数据同理；修改数据时，如果new data和old data长度相同，则设置好内部指针后直接写入；如果new > old，相当于增加内容，思路同插入；如果new < old，相当于删除内容，思路同删除

实际开发中，我们往往会保持新旧数据长度一致，以减少编程的工作量，所以我们不再讨论新旧数据长度不同的情况

## 文件复制函数


## 文件插入函数


## 文件删除函数

