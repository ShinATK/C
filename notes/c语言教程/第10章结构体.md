#编程基础  #c语言中文网 #c语言教程  
# 10.1 C语言结构体详解，C语言struct用法详解

在C语言中，可以使用**结构体（Struct）**来存放一组不同类型的数据。结构体的定义形式为：

```c
struct 结构体名{  
    结构体所包含的变量或数组  
};
```


- 结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。请看下面的一个例子：  

	```c
	1. struct stu{
	2.     char *name;  //姓名
	3.     int num;  //学号
	4.     int age;  //年龄
	5.     char group;  //所在学习小组
	6.     float score;  //成绩
	7. };
	```

- stu 为结构体名，它包含了 5 个成员，分别是 name、num、age、group、score。结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。
- 结构体可以包含多个基本类型的数据，也可以包含其他的结构体，**我们将它称为复杂数据类型或构造数据类型**

## 结构体变量

- 既然结构体是一种数据类型，那么就可以用它来定义变量。例如：

	```c
	struct stu stu1, stu2;
	
	// 在定义结构体时，定义结构体变量
	struct stu{
	    char *name;  //姓名
	    int num;  //学号
	    int age;  //年龄
	    char group;  //所在学习小组
	    float score;  //成绩
	} stu1, stu2;
	```

- **理论上**讲结构体的**各个成员在内存中是连续存储**的，和数组非常类似，
- 但是在编译器的具体实现中，各个成员之间**可能会存在缝隙**

## 成员的获取和赋值

- 数组使用下标`[ ]`获取单个元素，结构体使用点号`.`获取单个成员。获取结构体成员的一般格式为：

	```c
	结构体变量名.成员名;
	```

	```c
	#include <stdio.h>
	int main(){
	    struct{
	        char *name;  //姓名
	        int num;  //学号
	        int age;  //年龄
	        char group;  //所在小组
	        float score;  //成绩
	    } stu1;
	
	    //给结构体成员赋值
	    stu1.name = "Tom";
	    stu1.num = 12;
	    stu1.age = 18;
	    stu1.group = 'A';
	    stu1.score = 136.5;
	
	    //读取结构体成员的值
	    printf("%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n", stu1.name, stu1.num, stu1.age, stu1.group, stu1.score);
	
	    return 0;
	}
	```

需要注意的是：
- **结构体**是一种**自定义的数据类型**，是创建变量的模板，**不占用内存空间**；
- **结构体变量**才**包含了实实在在的数据**，**需要内存空间来存储**

# 10.2 C语言结构体数组详解（带实例演示）

## 结构体

所谓[==结构体数组==](https://c.biancheng.net/view/245.html)==，是指数组中的每个元素都是一个结构体==。在实际应用中，[C语言结构体数组](https://c.biancheng.net/view/245.html)常被用来表示一个==拥有相同[数据结构](https://c.biancheng.net/data_structure/)的群体==，比如一个班的学生、一个车间的职工等。

- 在C语言中，定义结构体数组和定义结构体变量的方式类似，请看下面的例子：
	- 结构体数组**在定义时可以初始化**
	- 当对数组中**全部元素赋值时**，**可以不给出数组长度**
	```c
	struct stu{
	    char *name;  //姓名
	    int num;  //学号
	    int age;  //年龄
	    char group;  //所在小组 
	    float score;  //成绩
	}class[] = {
	    {"Li ping", 5, 18, 'C', 145.0},
	    {"Zhang ping", 4, 19, 'A', 130.5},
	    {"He fang", 1, 18, 'A', 148.5},
	    {"Cheng ling", 2, 17, 'F', 139.0},
	    {"Wang ming", 3, 17, 'B', 144.5}
	};
	```
- 结构体数组的使用与修改：
	- `class[4].score;`
	- `class[0].group='B'`

# 10.3 C语言结构体指针（指向结构体的指针）详解

## 结构体指针

- 当一个[==指针==](https://c.biancheng.net/c/80/)==变量指向结构体==时，我们就称它为**[结构体指针](https://c.biancheng.net/view/246.html)**。[C语言结构体指针](https://c.biancheng.net/view/246.html)的定义形式一般为：  
	```c
	struct 结构体名 *变量名;
	```
	- 实际使用案例：
	```c
	//结构体
	struct stu{
	    char *name;  //姓名
	    int num;  //学号
	    int age;  //年龄
	    char group;  //所在小组
	    float score;  //成绩
	} stu1 = { "Tom", 12, 18, 'A', 136.5 };
	//结构体指针
	struct stu *pstu = &stu1;
	```

- 也可以在定义结构体同时定义结构体指针：
	```c
	struct stu{
	} stu1={...}, *pstu = &stu1;
	```

- 注意：==结构体变量名和数组名不同==
	- 数组名在表达式中会被转换为数组指针
	- 结构体变量名则一直表示**整个集合**本身，所以要获得结构体变量的地址，必须加上`&`
	```c
	struct stu *pstu = &stu1;
	```

- 注意：==结构体和结构体变量是两个不同的概念==
	- **结构体**：
		- 一种数据类型，创建变量的模板
		- 编译器不会分配内存空间
	- **结构体变量**：
		- 实际的数据，需要内存控件来存储
- ==错误示例==：
	```c
	struct stu *pstu = &stu;  // 不能取结构体名的地址，因为其本身只代表一种数据类型，没有实际数据，也并不占据内存空间
	struct stu *pstu = stu;   // 也不能将结构体名赋值给其他变量
	```

## 获取结构体成员

- 通过结构体指针可以获取结构体成员有两种方式：
	```c
	(*pointer).memberName // 这里的()不能少，因为.的优先级高于*
	```
	- 或者：
	```c
	pointer->memberName // -> 在c语言中的唯一用途
	```

## 结构体指针作为函数参数

- 与数组不同，数组名传入函数形参会被转换为指向数组第0个元素的内存地址，**但是结构体名不会进行这种转换**。
	- 和数组一样，防止将结构体全部拷贝到函数体的内存空间中会导致程序效率低下等问题
	- 可以利用**结构体指针**来将具体某一个**结构体变量**的地址传入函数形参之中
	```c
	#include <stdio.h>
	
	struct stu{
	    char *name;  //姓名
	    int num;  //学号
	    int age;  //年龄
	    char group;  //所在小组
	    float score;  //成绩
	}stus[] = {
	    {"Li ping", 5, 18, 'C', 145.0},
	    {"Zhang ping", 4, 19, 'A', 130.5},
	    {"He fang", 1, 18, 'A', 148.5},
	    {"Cheng ling", 2, 17, 'F', 139.0},
	    {"Wang ming", 3, 17, 'B', 144.5}
	};
	
	void average(struct stu *ps, int len);
	
	int main(){
	    int len = sizeof(stus) / sizeof(struct stu);
	    average(stus, len);
	    return 0;
	}
	
	void average(struct stu *ps, int len){
	    int i, num_140 = 0;
	    float average, sum = 0;
	    for(i=0; i<len; i++){
	        sum += (ps + i) -> score;
	        if((ps + i)->score < 140) num_140++;
	    }
	    printf("sum=%.2f\naverage=%.2f\nnum_140=%d\n", sum, sum/5, num_140);
	}
	```

# 10.4 C语言枚举类型（C语言enum用法）详解

## 枚举类型

在实际编程中，**有些数据的取值往往是有限的，只能是非常少量的整数，并且最好为每个值都取一个名字，以方便在后续代码中使用**，比如一个星期只有七天，一年只有十二个月，一个班每周有六门课程等。

枚举类型的定义形式为：
```c
enum typeName{ valueName1, valueName2, valueName3, ...... };
```

- `enum`是一个新的关键字，专门用来定义枚举类型，这也是它在C语言中的唯一用途；`typeName`是枚举类型的名字；`valueName1, valueName2, valueName3, ......`是每个值对应的名字的列表。注意最后的`;`不能少。
- 枚举值默认从0开始，如果对第一个名字赋值为1，则后边的名字依次递增
- 注意：
	- 枚举列表中的这些标识符的作用范围是全局或对应的mian()函数内部
	- 这些标识符都为常量，不能对它们赋值
## 与宏之间的关系

- 宏在**预处理阶段**将名字替换为对应的值
- 枚举在**编译阶段**将名字替换为对应的值
## 标识符的本质

- 标识符不是变量，所以
	- 不占用数据区（常量区、全局数据区、栈区和堆区）
	- 直接编译到命令里，放到代码区
	- 不能用 `&` 取得它们的地址

# 10.5 C语言共用体（C语言union用法）详解

**共用体（Union）**，它的定义格式为：

```c
union 共用体名{  
    成员列表  
};
```

> 共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。

- ==结构体和共用体的区别==在于：
	- ==结构体的各个成员会占用不同的内存，互相之间没有影响==；
		- 结构体占用内存**大于等于所有成员所占用内存之和**（因为成员之间可能存在缝隙）
	- ==而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员==
		- 共用体所占用内存等于最长成员占用的内存
		- **内存覆盖技术**：同一时刻只能保存一个成员的值

要想理解上面的输出结果，弄清成员之间究竟是如何相互影响的，就得了解各个成员在内存中的分布。以上面的 data 为例，各个成员在内存中的分布如下（大多是PC机上的内存分布情况）：  
![](https://c.biancheng.net/uploads/allimg/190118/152553G12-0.jpg)

- 共用体一般在编程中用的较少，在单片机中应用较多

# 10.6 大端小端以及判别方式

- 大端和小端是指==数据在内存中的存储模式==，它由 CPU 决定：  
	1) 大端模式（Big-endian）是指将==数据的低位==（比如 1234 中的 34 就是低位）放在==内存的高地址==上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。这种存储模式有点儿类似于把数据当作字符串顺序处理，==地址由小到大增加，而数据从高位往低位存放==。  
	 
	2) 小端模式（Little-endian）是指将==数据的低位==放在==内存的低地址==上，而数据的高位放在内存的高地址上。这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分，这和我们的思维习惯是一致，比较容易理解。

## 为什么有大小端模式之分

- 对于一次能处理多个字节的CPU，必然存在着如何安排多个字节的问题，也就是大端和小端模式。以 int 类型的 0x12345678 为例，它占用 4 个字节。

- 如果是小端模式（Little-endian），那么在内存中的分布情况为（假设从地址 0x 4000 开始存放）：  

|   |   |   |   |   |
|---|---|---|---|---|
|内存地址|0x4000|0x4001|0x4002|0x4003|
|存放内容|0x78|0x56|0x34|0x12|
  
- 如果是大端模式（Big-endian），那么分布情况正好相反：

|   |   |   |   |   |
|---|---|---|---|---|
|内存地址|0x4000|0x4001|0x4002|0x4003|
|存放内容|0x12|0x34|0x56|0x78|

我们的 ==PC 机上使用的是 X86 结构的 CPU，它是小端模式==；==51 单片机是大端模式==；很多 ARM、DSP 也是小端模式（部分 ARM 处理器还可以由硬件来选择是大端模式还是小端模式）

- 利用共用体检测CPU是大端模式还是小端模式：
	```c
	#include <stdio.h>
	int main(){
		union {
			int n;
			char ch;	
		} data;
		data.n = 0x00000001;
		if(data.ch == 1){
			printf("Little-endian\n");
		}
		else{
			printf("Big-endian\n");
		}
		return 0;
	}
	```
	- 共用体的各个成员是共用一段内存的。1 是数据的低位，如果 1 被存储在 data 的低字节，就是小端模式，这个时候 data.ch 的值也是 1。如果 1 被存储在 data 的高字节，就是大端模式，这个时候 data.ch 的值就是 0。

# 10.7 C语言位域（位段）详解

## 位域

有些数据在存储时并不需要占用一个完整的字节，**只需要占用一个或几个二进制位**即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做**位域**的[数据结构](https://c.biancheng.net/data_structure/)。

在结构体定义时，我们可以指定某个成员变量所占用的**二进制位数（Bit）**，这就是位域。请看下面的例子：

```c
1. struct bs{
2.     unsigned m;
3.     unsigned n: 4; // 这里的4是 4 bit，而unsigned为4 字节是Byte
4.     unsigned char ch: 6;
5. };
```

`:`后面的数字用来==限定成员变量占用的位数==。成员 m 没有限制，根据数据类型即可推算出它占用 4 个字节（Byte）的内存。成员 n、ch 被`:`后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、6 位（Bit）的内存。

- C语言标准规定，
	- **位域的宽度不能超过它所依附的数据类型的长度**
	- **只有有限的几种数据类型可以用于位域**
		- 在 ANSI C 中，这几种数据类型是 int、signed int 和 unsigned int（==int 默认就是 signed int==）
		- C99中，`_Bool` 也被支持了
- 位域技术就是在成员变量所占用的内存中选出一部分位宽来存储数据

## 位域的存储

- C语言标准并没有规定位域的具体存储方式，不同的编译器有不同的实现，但它们**都尽量压缩存储空间**。

- **存储规则：**
	1) 如果**相邻成员类型相同**（内存要对其4个字节）
		- **位宽之和小于类型sizeof的大小**，则后面成员**紧邻**前一个成员存储，直到不能容纳
		- **位宽之和大于类型sizeof的大小**，则后面成员将从**新的存储单元开始**，偏移量为类型大小整数倍
	2) 如果**相邻成员类型不同**
		- GCC会压缩存储
		- VC/VS不会
	3) 如果**成员之间穿插非位域成员**，不会进行压缩
- 通过上面的分析，我们发现位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用`&`获取位域成员的地址是没有意义的，C语言也禁止这样做。**地址是字节（Byte）的编号**，而不是位（Bit）的编号。

## 无名位域

位域成员可以没有名称，只给出数据类型和位宽，如下所示：

```c
1. struct bs{
2.     int m: 12;
3.     int  : 20;  //该位域成员不能使用
4.     int n: 4;
5. };
```

无名位域一般用来作==填充或者调整成员位置==。因为没有名称，无名位域不能使用。

# 10.8 C语言位运算（按位与运算、或运算、异或运算、左移运算、右移运算）

==所谓位运算，就是对一个比特（Bit）位进行操作==。在《[数据在内存中的存储](https://c.biancheng.net/view/1726.html)》一节中讲到，比特（Bit）是一个电子元器件，8个比特构成一个字节（Byte），它已经是粒度最小的可操作单元了。  
  
C语言提供了==六种位运算符==：  

|        |        |        |          |      |      |      |
| ------ | ------ | ------ | -------- | ---- | ---- | ---- |
| 运算符 | &      | \|     | ^        | ~    | <<   | >>   |
| 说明   | 按位与 | 按位或 | 按位异或 | 取反 | 左移 | 右移 |


- **C语言中不能直接使用二进制**
- **注意：**
	- 位运算是根据内存中的二进制位运算，而不是数据的二进制形式
	- 例如：数字在内存中以**补码**形式保存，所以直接使用数据二进制进行位运算会出错

- **按位与运算（&）**
	- 用来*对某些位清 0，或者保留某些位*
- **按位或运算（|）**
	- 用来*对某些位置 1，或者保留某些位*
- **按位异或运算（^）**
	- 按位异或运算可以用来*将某些二进制位反转*
- **取反运算（~）**
	- 单目运算符，右结合性。对参与运算的二进制位取反
- **左移运算（<<）**
	- 把操作数的各个二进制位全部左移若干位，==高位丢弃，低位补0==
	- 如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方
- **右移运算（>>）**
	- 把操作数的各个二进制位全部右移若干位，==低位丢弃，高位补 0 或 1==。==如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1==。
	- 如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方（但被移除的位中经常会包含 1）

# 10.9 使用位运算对数据或文件内容进行加密

数据加密解密的原理也很简单，就是使用**异或运算**
- 两次异或运算后还是原来的结果

```c
#include <stdio.h>
#include <stdlib.h>

int main(){
    char plaintext = 'a';  // 明文
    char secretkey = '!';  // 密钥
    char ciphertext = plaintext ^ secretkey;  // 密文
    char decodetext = ciphertext ^ secretkey;  // 解密后的字符
    char buffer[9];

    printf("            char    ASCII\n");
    // itoa()用来将数字转换为字符串，可以设定转换时的进制（基数）
    // 这里将字符对应的ascii码转换为二进制
    printf(" plaintext   %c     %7s\n", plaintext, itoa(plaintext, buffer, 2));
    printf(" secretkey   %c     %7s\n", secretkey, itoa(secretkey, buffer, 2));
    printf("ciphertext   %c     %7s\n", ciphertext, itoa(ciphertext, buffer, 2));
    printf("decodetext   %c     %7s\n", decodetext, itoa(decodetext, buffer, 2));

    return 0;
}
```

运行结果：

```c
            char    ASCII
 plaintext   a     1100001
 secretkey   !      100001
ciphertext   @     1000000
decodetext   a     1100001
```

- 对称加密算法
	- 加密和解密使用同一个密钥
- 非对称加密算法
	- 加密和解密的密钥不同
	- 加密的密钥称为公钥，解密的密钥称为私钥
