#编程基础  #c语言中文网 #c语言教程  

**函数的本质是一段可以重复使用的代码**

- C语言**不允许函数嵌套定义**
  - 但可以嵌套使用，只是不允许在函数内部定义另一个函数而已

```c
#include <stdio.h>

void func2(){
    printf("C语言小白变怪兽");
}

void func1(){
    printf("http://c.biancheng.net");
    func2();
}

int main(){
    func1();
    return 0;
}
```

- func1()、func2()、main() 三个函数是平行的，谁也不能位于谁的内部，要想达到「调用 func1() 时也调用 func2()」的目的，必须将 func2() 定义在 func1() 外面，并在 func1() 内部调用 func2()。

# 7.3 C语言形参和实参的区别（非常详细）

## 形参和实参的区别和联系

#### 形参（形式参数）

- 在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为**形式参数**，简称**形参**。

#### 实参（实际参数）

- 函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为**实际参数**，简称**实参**

1) **形参变量**只有**在函数被调用时才会分配内存**，**调用结束后，立刻释放内存**，所以形参变量只有在函数内部有效，不能在函数外部使用。

2) 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。

3) 实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。

4) 函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有瓜葛了，所以，在函数调用过程中，形参的值发生改变并不会影响实参。

# 7.6 C语言函数声明以及函数原型

- 通常是将**函数定义**放到**源文件（`.c`文件）**中，将**函数的声明**放到**头文件（`.h`文件）**中，**使用函数时引入对应的头文件**就可以，编译器会在链接阶段找到函数体
- 除了函数，**变量也有定义和声明**之分。实际开发过程中，变量定义需要放在源文件（`.c`文件）中，变量声明需要放在头文件（`.h`文件）中，在链接程序时会将它们对应起来

- 最后再补充一点，**函数原型**给出了**使用该函数的所有细节**，当我们不知道如何使用某个函数时，需要查找的是它的原型，而不是它的定义，我们往往不关心它的实现。

# 7.7 C语言全局变量和局部变量（带实例讲解）

- **作用域（Scope）**，就是变量的有效范围

## 局部变量

- 定义在函数内部的变量称为**局部变量（Local Variable）**，它的作用域仅限于函数内部， 离开该函数后就是无效的，再使用就会报错。

1) 在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。

2) **形参变量**、在函数体内定义的变量都是局部变量。实参给形参传值的过程也就是给局部变量赋值的过程。

3) 可以在不同的函数中使用相同的变量名，它们表示不同的数据，分配不同的内存，互不干扰，也不会发生混淆。

4) 在语句块中也可定义变量，它的作用域只限于当前语句块。

## 全局变量

- 在所有函数外部定义的变量称为**全局变量（Global Variable）**，它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件

## 局部变量和全局变量的综合示例

```c
#include <stdio.h>

int n = 10;  //全局变量

void func1(){
    int n = 20;  //局部变量
    printf("func1 n: %d\n", n); // 20 局部变量
}

void func2(int n){
    printf("func2 n: %d\n", n); // 30 传入的变量n
}

void func3(){
    printf("func3 n: %d\n", n); // 10 全局变量
}

int main(){
    int n = 30;  //局部变量
    func1();
    func2(n);
    func3();
    //代码块由{}包围
    {
        int n = 40;  //局部变量
        printf("block n: %d\n", n); // 40 自己代码块的局部变量
    }
    printf("main n: %d\n", n); // 30 main函数的局部变量

    return 0;
}
```

-  C语言规定，只能**从小的作用域向大的作用域中去寻找变量**，而不能反过来，使用更小的作用域中的变量。

- 面积 s1、s2、s3 设置为全局变量。**全局变量的作用域是整个程序**，在函数 vs() 中修改 s1、s2、s3 的值，能够影响到包括 main() 在内的其它函数
  - 在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改

```c
#include <stdio.h>

int s1, s2, s3;  //面积

int vs(int a, int b, int c){
    int v;  //体积
    v = a * b * c;
    s1 = a * b;
    s2 = b * c;
    s3 = a * c;
    return v;
}

int main(){
    int v, length, width, height;
    printf("Input length, width and height: ");
    scanf("%d %d %d", &length, &width, &height);
    v = vs(length, width, height);
    printf("v=%d, s1=%d, s2=%d, s3=%d\n", v, s1, s2, s3);

    return 0;
}
```

# 7.8 C语言变量的作用域，加深对全局变量和局部变量的理解

- 给全局变量加上 **static** 关键字，它的**作用域就变成了当前文件**，在其它文件中就无效了
- 函数内部的局部变量和函数外部的全局变量同名时，在当前函数这个局部作用域中，全局变量会被“屏蔽”

# 7.11 C语言中间递归函数（比较复杂的一种递归）

尾递归在逐层退出时除了 return 语句，一般不再执行其他操作；而中间递归在逐层退出时还要执行一些其他的操作，所以比较复杂。

**字符串反转（逆置）函数**：

```c
#include <stdio.h>
#include <string.h>

//反转（逆置）字符串
char *reverse(char *str) {
    int len = strlen(str);
    if (len > 1) {
        char ctemp = str[0];
        str[0] = str[len - 1];
        str[len - 1] = '\0';  //最后一个字符在下次递归时不再处理
        reverse(str + 1);  //递归调用
        str[len - 1] = ctemp;
    }
    return str;
}

int main() {
    char str[20] = "123456789";
    printf("%s\n", reverse(str));
    return 0;
}
```

两个关键点：

- 每次调用函数，都会把字符串的第 0 个字符保存到 ctemp 变量，并把最后一个字符填充到第 0 个字符的位置，同时**用`'\0'`来填充最后一个字符的位置**
- 注意第 11 行代码，调用 reverse() 的实参为`str+1`，这会导致形参 str 的指向发生改变，**每次递归调用时 str 都会向后移动一个字符的位置**
- 即：每次的递归调用，str所指向的字符串都是上一个字符串的子串，循环对每一个子串掐头（存入ctemp）去尾（放到该子串的首位）操作，并将“去尾”部分的字符更换为`\0`，这一部分主要是将字符串后半部分倒序放到字符串前部；递归完毕时逐层退出，此时各层存放在ctemp中的子串原首位变会被放到该子串的末尾
- ![中间递归的流程](https://c.biancheng.net/uploads/allimg/190104/1-1Z104112100B6.gif)
- 对于中间递归来说，它在进入和退出递归的两个阶段都会进行一些操作

# 7.12 C语言多层递归函数（最烧脑的一种递归）

- 菲波那契数

  - ![img](https://c.biancheng.net/uploads/allimg/190104/1-1Z104141403U9.gif)

  - ```c
    #include <stdio.h>
    
    //递归计算斐波那契数
    long fib(int n) {
        if (n <= 2) {
            return 1;
        }
        else {
            return fib(n - 1) + fib(n - 2);
        }
    }
    
    int main() {
        int a;
        printf("Input a number: ");
        scanf("%d", &a);
        printf("Fib(%d) = %ld\n", a, fib(a));
    
        return 0;
    }
    ```

  - ![多层递归调用演示图](https://c.biancheng.net/uploads/allimg/190104/1-1Z104142ZO15.gif)

  - **双层递归常用于二叉树的遍历**

  - 单层递归每次只等待一个函数的结果，双层递归每次要等待两个函数的结果，这就是它们之间最本质的区别。

# 7.13 递归函数的致命缺陷：巨大的时间开销和内存开销（附带优化方案）

## 递归函数的空间开销

- 在程序占用的整个内存中，有一块内存区域叫做**栈（Stack）**，它是专门用来给函数分配内存的，每次调用函数，都会将相关数据压入栈中，包括局部变量、局部数组、形参、寄存器、冗余数据等
- 栈是针对线程来说的，每个线程都拥有一个栈，如果一个程序包含了多个线程，那么它就拥有多个栈。目前我们编写的程序都是单线程的，所以不必考虑多线程的情况。
- 对每个线程来说，栈能使用的内存是有限的，一般是 1M~8M(和编译器有关)，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误

## 递归函数的时间开销

- 每次调用函数都会在栈上分配内存，函数调用结束后再释放这一部分内存，内存的分配和释放都是需要时间的。
- 每次调用函数还会多次修改寄存器的值，函数调用结束后还需要找到上层函数的位置再继续执行，这也是需要时间的。

## 使用迭代来替换递归函数

函数调用本来就存在内存开销和时间开销，递归一次这种开销就增加一倍，如果有成千上万次的递归，那么所有开销的总和就是巨大的。这是递归的致命缺陷，无法优化。所以建议大家尽量少用递归，**能用迭代就用迭代吧**。

# 7.14 忽略语法细节，从整体上理解函数

标准C语言（[ANSI C](https://c.biancheng.net/view/vip_1742.html)）共定义了15 个头文件，称为“C标准库”，所有的编译器都必须支持，如何正确并熟练的使用这些标准库，可以反映出一个程序员的水平。

- 合格程序员：`<stdio.h>`、[`<ctype.h>`](https://c.biancheng.net/ref/ctype_h/)、`<stdlib.h>`、`<string.h>`
- 熟练程序员：`<[assert.h](https://c.biancheng.net/ref/assert_h/)>`、`<[limits.h](https://c.biancheng.net/ref/limits_h/)>`、`<stddef.h>`、`<time.h>`
- 优秀程序员：`<[float.h](https://c.biancheng.net/ref/float_h/)>`、[`<math.h>`](https://c.biancheng.net/ref/math_h/)、`<error.h>`、[`<locale.h>`](https://c.biancheng.net/ref/locale_h/)、`<setjmp.h>`、`<signal.h>`、`<stdarg.h>`

