#编程基础  #c语言中文网 #c语言教程  
# 6.4 C语言字符数组和字符串详解

- 字符数组只有在定义时才能将整个字符串一次性地赋值给它，一旦定义完了，就只能一个字符一个字符地赋值了

  ## 字符串结束标志（划重点）

- 找到字符串的开头很容易，知道它的名字（字符数组名或者字符串名）就可以；然而，如何找到字符串的结尾呢？
- **在C语言中，字符串总是以`'\0'`作为结尾，所以`'\0'`也被称为字符串结束标志，或者字符串结束符。**

> `'\0'`是 ASCII 码表中的第 0 个字符，英文称为 NUL，中文称为“空字符”。该字符既不能显示，也没有控制功能，输出该字符不会有任何效果，它在C语言中唯一的作用就是作为字符串结束标志。

- 由`" "`包围的字符串会自动在末尾添加`'\0'`

  - 字符串中`'\0'`为隐式添加故`"C program"`在内存中的存储方式为：
  - ![img](https://c.biancheng.net/uploads/allimg/190102/103521G44-0.png)
  - 这意味着，**字符数组**的长度至少要比**字符串**的长度大 1

- 逐个字符地给数组赋值并不会自动添加`'\0'`

- 要想避免字符串问题也很容易，在字符串的最后手动添加`'\0'`即可

  - 更加专业的做法是将数组的所有元素都初始化为“零”值，这样才能够从根本上避免问题
  - `char str[30] = {0}; `如果只初始化部分数组元素，那么剩余的数组元素也会自动初始化为“零”值，所以我们只需要将 str 的第 0 个元素赋值为 0，剩下的元素就都是 0 了

  ## 字符串长度

  - 使用`string.h`头文件中的` strlen()` 函数来求字符串的长度
    - `length = strlen(strname);`

# 6.5 字符串的输入和输出

## 输出

- puts()：输出字符串并自动换行，该函数只能输出字符串。
- printf()：通过格式控制符`%s`输出字符串，不能自动换行。除了字符串，printf() 还能输出其他类型的数据。
- 输出字符串时只需要给出名字，不能带后边的`[ ]`

## 输入

- scanf()：通过格式控制符`%s`输入字符串。除了字符串，scanf() 还能输入其他类型的数据
  - 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串
- gets()：直接输入字符串，并且只能输入字符串
  - 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束
  - **gets() 用来读取一整行字符串**

```c
printf("Input a string: ");
scanf("%s", str2);
scanf("%s", str3);
```

- **字符串名字或者数组名字**在使用的过程中一般都会**转换为地址**，所以再添加`&`就是多此一举，甚至会导致错误了

# 6.6 C语言字符串处理函数

## 字符串连接函数 strcat()

- strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：
  - 把 arrayName2 连接到 arrayName1 后面，并删除原来 arrayName1 最后的结束标志`'\0'`。这意味着，**arrayName1 必须足够长**，要能够同时容纳 arrayName1 和 arrayName2，否则会越界（超出范围）

```c
strcat(arrayName1, arrayName2);
```

## 字符串复制函数 strcpy()

- strcpy 是 string copy 的缩写，意思是字符串复制，也即将字符串从一个地方复制到另外一个地方，语法格式为：
  - strcpy() 会把 arrayName2 中的字符串拷贝到 arrayName1 中，字符串结束标志`'\0'`也一同拷贝
  - strcpy() 要求 **arrayName1 要有足够的长度**，否则不能全部装入所拷贝的字符串

```c
strcpy(arrayName1, arrayName2);
```

## 字符串比较函数 strcmp()

- strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：
  - 以各个字符对应的 ASCII 码值进行比较
  - 从两个字符串的第 0 个字符开始比较，如果它们相等，就继续比较下一个字符，直到遇见不同的字符，或者到字符串的末尾

```
strcmp(arrayName1, arrayName2);
```

# 6.7 C语言数组是静态的，不能插入或删除元素

**C语言中的数组是静态的，一旦定义后长度就不能改变了，大家要注意这一点，不要尝试去插入或删除元素**

## C语言数组为什么是静态的

- **插入和删除数组元素都要移动内存，甚至重新开辟一块内存，这是相当消耗资源的**。如果一个程序中有大量的此类操作，那么程序的性能将堪忧，这有悖于「C语言非常高效」的初衷，所以C语言并不支持动态数组。
  - 很多时候我们需要把数组的地址保存到一个变量里面（指针），如果数组重新开辟了内存，而变量里面的地址不跟着改变的话，后续再使用该变量就会导致错误
- 为了保证程序执行效率，为了防止操作错误，C语言只支持静态数组，不支持动态数组。

# 6.8 C语言数组的越界和溢出

## 数组越界 Out Of Bounds

- **访问的内存位置在数组以外**
  - 下限越界（Off Normal Lower）
  - 上限越界（Off Normal Upper）

- C语言为了提高效率，保证操作的灵活性，并不会对越界行为进行检查，即使越界了，也能够正常编译，**只有在运行期间才可能会发生问题**。

- 由于C语言的”放任“，我们**访问数组时必须非常小心，要确保不会发生越界。**

## 数组溢出 Overflow

- **赋予数组的元素个数**超过**数组长度**

# 6.9 C语言变长数组：使用变量指明数组的长度

- **在 C89 中，必须使用常量表达式指明数组长度**；也就是说，数组长度中不能包含变量，不管该变量有没有初始化。
- 而**在 C99 中，可以使用变量指明数组长度**。

- 变量的值在编译期间并不能确定，只有等到程序运行后，根据计算结果才能知道它的值到底是什么，所以数组长度中一旦包含了变量，那么数组长度在编译期间就不能确定了，也就不能为数组分配内存了，只有等到程序运行后，得到了变量的值，确定了具体的长度，才能给数组分配内存，我们将这样的数组称为**变长数组(VLA, Variable Length Array)**。
- **普通数组（固定长度的数组）**是在**编译期间**分配内存的，而**变长数组**是在**运行期间**分配内存的

- **变长数组仍然是静态数组**
  - 可变只是定义之前可变

# 6.10 C语言对数组元素进行排序（冒泡排序法）

- 对数组元素进行排序的方法有很多种，比如冒泡排序、归并排序、选择排序、插入排序、快速排序等，其中**最经典最需要掌握的是「冒泡排序」**
  - 从数组头部开始，不断比较相邻的两个元素的大小，让较大的元素逐渐往后移动（交换两个元素的值），直到数组的末尾。经过第一轮的比较，就可以找到最大的元素，并将它移动到最后一个位置。
  - 第一轮结束后，继续第二轮。仍然从数组头部开始比较，让较大的元素逐渐往后移动，直到数组的倒数第二个元素为止。经过第二轮的比较，就可以找到次大的元素，并将它放到倒数第二个位置。
  - 以此类推，进行 n-1（n 为数组长度）轮“冒泡”后，就可以将所有的元素都排列好。

```c
#include <stdio.h>
int main(){
    int nums[10] = {4, 5, 2, 10, 7, 1, 8, 3, 6, 9};
    int i, j, temp;

    //冒泡排序算法：进行 n-1 轮比较
    for(i=0; i<10-1; i++){
        //每一轮比较前 n-1-i 个，也就是说，已经排序好的最后 i 个不用比较
        for(j=0; j<10-1-i; j++){
            if(nums[j] > nums[j+1]){
                temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
   
    //输出排序后的数组
    for(i=0; i<10; i++){
        printf("%d ", nums[i]);
    }
    printf("\n");
   
    return 0;
}
```

## 优化算法

- 优化的部分：当比较到第 i 轮的时候，如果剩下的元素已经排序好了，那么就不用再继续比较了，跳出循环即可，这样就减少了比较的次数，提高了执行效率。

- 未经优化的算法**一定**会进行 n-1 轮比较，经过优化的算法**最多**进行 n-1 轮比较

```c
#include <stdio.h>
int main(){
    int nums[10] = {4, 5, 2, 10, 7, 1, 8, 3, 6, 9};
    int i, j, temp, isSorted;
   
    //优化算法：最多进行 n-1 轮比较
    for(i=0; i<10-1; i++){
        isSorted = 1;  //假设剩下的元素已经排序好了
        for(j=0; j<10-1-i; j++){
            if(nums[j] > nums[j+1]){
                temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
                isSorted = 0;  //一旦需要交换数组元素，就说明剩下的元素没有排序好
            }
        }
        if(isSorted) break; //如果没有发生交换，说明剩下的元素已经排序好了
    }

    for(i=0; i<10; i++){
        printf("%d ", nums[i]);
    }
    printf("\n");
   
    return 0;
}
```

- **按照冒泡排序法，其核心思想是将大数逐个移动到数组后方，第一次是最大数移动到最后，第二次是次大，第三次等等类推。**
  - 如果不设置isSorted，那么按照该方法，假设数组中有n个数，最终一定会进行n-1轮，每次都需要从数组前方一直比较到第n-i个位置，**相当于固定对数组从头到尾全访问了一遍**，所以有可能会发生还没有进行到第n-1轮比较时，就已经完成排序的情况。
  - **所以，可以给每轮移动中设置标识isSorted，在一轮移动中，存在需要交换数组的情况，就说明数组还没有排序好，完成本次排序并将isSorted置为0，从而进行下一轮比较。但如果该轮比较中没有发生数组交换，即说明不再需要进行排序，则isSorted继续保持为1，从而跳过剩下对数组的循环**