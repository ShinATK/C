#编程基础  #c语言中文网 #c语言教程  

- **指针**，也就是**内存的地址**；
- **指针变量**，也就是**保存了内存地址**的变量

#  9.1 C语言指针是什么？

将内存中字节的编号称为**地址（Address）或指针（Pointer）**。地址从 0 开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。

- CPU只能通过地址来取得内存中的代码和数据，数据和代码都以二进制的形式存储在内存中，计算机**无法从格式上区分**某块内存到底存储的是数据还是代码
	- 拥有**读取**和**执行权限**的*内存块*就是代码
	- 拥有**读取**和**写入权限**（**也可能只有读取权限**）的*内存块*就是数据
- CPU 访问内存时需要的是地址
	- 变量名和函数名只是地址的一种**助记符**
	- 当源文件被编译和链接成可执行程序后，它们都会**被替换成地址**。
	- 编译和链接过程的一项重要任务就是**找到这些名称所对应的地址**。
		- 假设变量 a、b、c 在内存中的地址分别是 0X1000、0X2000、0X3000，那么加法运算`c = a + b;`将会被转换成类似下面的形式：`0X3000 = (0X1000) + (0X2000);`
		- `( )`表示取值操作，整个表达式的意思是，取出地址 0X1000 和 0X2000 上的值，将它们相加，把相加的结果赋值给地址为 0X3000 的内存
- 需要注意：
- 在**编写代码的过程**中，我们**认为变量名表示的是数据本身**，而**函数名、字符串名和数组名表示的是代码块或数据块的首地址**

# 9.2 C语言指针变量的定义和使用（精华）

## 定义指针变量

- 如果一个变量存储了一份数据的指针，我们就称它为**指针变量**
- `datatype *name;`
- `*`表示，`name`是一个指针变量，`datatype`是其所指向的数据的类型
- 初始化时，`int *p_a = &a`，需要用`&`来获得变量的地址
- 定义指针变量时必须带`*`，给指针变量赋值时不能带`*`。

## 通过指针变量获取数据

- `*pointer;`
- 这里的`*`为指针运算符，用来取得某个地址上的数据
- 指针和变量名获取数据的区别
	- 使用**指针**是**间接**获取数据
	- 使用**变量名**是**直接**获取数据
	- 前者比后者的代价要高

## 关于 `*` 和 `&` 的谜题

- 假设有一个 int 类型的变量 a，pa 是指向它的指针，那么`*&a`和`&*pa`分别是什么意思呢？
	- `*&a`可以理解为`*(&a)`，`&a`表示取变量 a 的地址（等价于 pa），`*(&a)`表示取这个地址上的数据（等价于 `*pa`），绕来绕去，又回到了原点，`*&a`仍然等价于 `a`。
	- `&*pa`可以理解为`&(*pa)`，`*pa`表示取得 `pa` 指向的数据（等价于 `a`），`&(*pa)`表示数据的地址（等价于 `&a`），所以`&*pa`等价于 `pa`。
## 星号`*`的三种用途

- 表示乘法
- 表示**定义**一个指针变量，以和普通变量区分开，例如`int a = 100;  int *p = &a;`。
- 表示**获取**指针指向的数据，是一种间接操作，例如`int a, b, *p = &a;  *p = 100;  b = *p;`。

# 9.3 C语言指针变量的运算（加法、减法和比较运算）

- 指针变量保存的是地址，而地址本质上是一个整数，所以**指针变量可以进行部分运算**，例如**加法、减法、比较**等
- 指针变量加减运算的结果跟数据类型的长度有关

# 9.4 C语言数组指针（指向数组的指针）详解

## 数组指针定义

- 数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存
- 数组名==可以认为==是一个[指针](https://c.biancheng.net/c/80/)
	- 在C语言中，我们将第 0 个元素的地址称为数组的首地址
	- ==sizeof(arr) 会获得整个数组所占用的字节数==，==sizeof(int) 会获得一个数组元素所占用的字节数==，它们相除的结果就是数组包含的元素个数，也即数组长度
	- 严格来说应该是“==arr 被转换成了一个指针==”
- 如果一个指针指向了数组，我们就称它为**数组指针**（Array Pointer）。
	- **需要注意的是**：
	- 在求数组的长度时不能使用`sizeof(p) / sizeof(int)`，**因为 p 只是一个指向 int 类型的指针**，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以 sizeof(p) 求得的是 p 这个指针变量本身所占用的字节数，而不是整个数组占用的字节数
## 引入数组指针，访问数组元素的两种方案

1) 使用下标
	- 也就是采用 `arr[i]` 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 `p[i]` 来访问数组元素，它等价于 `arr[i]`。
2) 使用指针
	- 也就是使用 `*(p+i)` 的形式访问数组元素。另外数组名本身也是指针，也可以使用 `*(arr+i)` 来访问数组元素，它等价于 `*(p+i)`。
## 数组指针与数组名之间的区别

- 数组指针是一个**变量**，它的值可以被改变，不仅可以指向数组的开头，还能指向其他元素
- 数组名是一个**常量**，它的值无法背改变，只能指向数组的开头

## 关于数组指针的谜题

- 假设 p 是指向数组 arr 中第 n 个元素的指针，那么 `*p++`、`*++p`、`(*p)++` 分别是什么意思呢？
	- `*p++` 等价于 `*(p++)`，表示==先取得第 n 个元素的值==，==再将 p 指向下一个元素==，上面已经进行了详细讲解。  
	- `*++p` 等价于 `*(++p)`，会==先进行 ++p 运算，使得 p 的值增加，指向下一个元素==，整体上相当于 `*(p+1)`，所以会获得第 n+1 个数组元素的值。  
	- `(*p)++` 就非常简单了，会==先取得第 n 个元素的值，再对该元素的值加 1==。假设 p 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。

# 9.5 C语言字符串指针（指向字符串的指针）详解

**C语言中没有特定的字符串类型**

## 字符数组

```C
#include <stdio.h>
#include <string.h>

int main(){
    char str[] = "http://c.biancheng.net"; // 字符数组
    int len = strlen(str), i;
    
    //直接输出字符串
    printf("%s\n", str);
    
    //每次输出一个字符
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    
    return 0;
}
```

字符数组归根结底还是一个数组，关于[指针](https://c.biancheng.net/c/80/)和数组的规则同样也适用于字符数组

## 字符串常量

`char *str = "http://c.biancheng.net";`

- 输出字符串

```c
#include <stdio.h>
#include <string.h>

int main(){
    char *str = "http://c.biancheng.net";
    int len = strlen(str), i;
   
    //直接输出字符串
    printf("%s\n", str);
    
    //使用*(str+i)
    for(i=0; i<len; i++){
        printf("%c", *(str+i));
    }
    printf("\n");
    
    //使用str[i]
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");

    return 0;
}
```

## 字符数组和字符串常量之间的区别

- 本质区别**在内存的存储区域不同**
	- 字符数组：存储在全局数据区或栈区（有读取和写入权限）
	- 字符串常量：存储在**常量区**（只有读取权限，不能写入）
		- 所以，字符串常量一旦被定义后就不能修改了
		- 但是字符串常量本身是一个指针，**其自身的指向**还是可以改变的，只是它**所指向的字符串**不能被修改
	- 所以，要注意对字符串读取和写入的需求
		- 如果有**写入或读取**操作，就只能用字符数组了

```c
#include <stdio.h>
int main(){
    char *str = "Hello World!";
    str = "I love C!";  //正确
    str[3] = 'P';  //错误

    return 0;
}
```

# 9.6 C语言数组灵活多变的访问形式

printf() 输出字符串时，要求给出一个起始地址，并从这个地址开始输出，直到遇见字符串结束标志`\0`


# 9.7 C语言指针变量作为函数参数

- 用==指针变量作函数参数==可以==将函数外部的地址传递到函数内部==，使得在==函数内部可以操作函数外部的数据==，==并且这些数据不会随着函数的结束而被销毁==。

- 像数组、字符串、动态分配的内存等都是一系列数据的集合，没有办法通过一个参数全部传入函数内部，只能传递它们的指针，==在函数内部通过指针来影响这些数据集合==。

- 利用指针变量交换两数
```c
#include <stdio.h>

void swap(int *p1, int *p2){
	int temp;
	temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}

int main(){
	int a=66, b=99;
	swap(&a, &b);
	printf("a=%d, b=%d", a, b); // a = 99, b = 66
	return 0;
}
```

## 数组做函数参数

- 数组是一系列数据的集合，无法通过参数将它们一次性传递到函数内部，==如果希望在函数内部操作数组，必须传递数组指针==。
- ==参数 intArr 仅仅是一个数组指针，在函数内部无法通过这个指针获得数组长度，必须将数组长度作为函数参数传递到函数内部==。数组 nums 的每个元素都是整数，scanf() 在读取用户输入的整数时，要求给出存储它的内存的地址，`nums+i`就是第 i 个数组元素的地址。
- 但用数组作为参数，并不会导致错误
	- `int max(int intArr[6], int len){}`
	- `int max(int intArr[], int len){}`
	- 但实际上，`intArr[6]`和`intArr[]`会被自动转换成指针，并不会创建新的数组，也不会分配内存，所以同样无法将数组数据一次性全部传递进来
	- **无法在函数内部求得数组的长度**，因为`intArr`只是一个指针

## 不允许直接传递数组所有元素的原因

- 参数的传递本质上是一次**赋值**操作，赋值=对内存的拷贝：将一块内存的数据复制到另一块内存上
- 如果允许直接传递数组所有元素，当数组的元素非常多时，对数组所在的内存进行拷贝是一个非常漫长的过程，严重拖慢程序效率
- 所以，只允许通过数组指针传递

# 9.8 C语言指针作为函数返回值

- C语言允许==函数的返回值是一个==[==指针==](https://c.biancheng.net/c/80/)==（地址），我们将这样的函数称为====指针函数==。

```c
#include <stdio.h>
#include <string.h>

// 注意这里的函数名声明方式
char *strlong(char *str1, char *str2){
    if(strlen(str1) >= strlen(str2)){
        return str1;
    }else{
        return str2;
    }
}

int main(){
    char str1[30], str2[30], *str;
    gets(str1);
    gets(str2);
    str = strlong(str1, str2);
    printf("Longer string: %s\n", str);

    return 0;
}
```
- 用指针作为函数返回值时需要注意的一点是，==函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数==，==函数返回的指针请尽量不要指向这些数据==，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。
- 这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而**是程序放弃对它的使用权限**，弃之不理，后面的代码可以随意使用这块内存

# 9.9 C语言二级指针（指向指针的指针）详解

- [指针](https://c.biancheng.net/c/80/)可以指向一份普通类型的数据，例如 int、double、char 等，也可以指向一份指针类型的数据，例如 `int *`、`double *`、`char *` 等

- 指针变量也是一种变量，也会占用存储空间，也可以使用`&`获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号`*`。p1 是一级指针，指向普通类型的数据，定义时有一个`*`；p2 是二级指针，指向一级指针 p1，定义时有两个`*`。
- **实际开发中一般只会用到一级和二级指针，几乎用不到高级指针**

# 9.10 C语言空指针NULL以及void指针

## 空指针 NULL

- NULL 是在`stdio.h`中定义的一个宏，它的具体内容为：
	- `#define NULL ((void *)0)`
	- `(void *)0`表示把数值 0 强制转换为`void *`类型，最外层的`( )`把宏定义的内容括起来，防止发生歧义。==从整体上来看，NULL 指向了地址为 0 的内存，而不是前面说的不指向任何数据==。
- 一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，也不管该内存有没有使用权限，只要把地址给它，它就可以指向。==C语言没有一种机制来保证指向的内存的正确性==，程序员必须自己提高警惕。
- ==未初始化的局部变量的值是不确定的==，C语言并没有对此作出规定，不同的编译器有不同的实现，我曾警告大家==不要直接使用未初始化的局部变量==。
- 强烈建议==对没有初始化的指针赋值为 NULL==，例如：  `char *str = NULL;`
	- 注意区分大小写
	- 注意`NULL`和`NUL`的区别：
		- `NULL`：空指针，宏定义，可以直接在代码中使用
		- `NUL`：字符串的结束标志`\0`，ASCII码表中的第0个字符。没有在c语言中定义
```c
void func(char *p){
    if(p == NULL){
        printf("(null)\n");
    }else{
        printf("%s\n", p);
    }
}
```
- 这样==能够从很大程度上增加程序的健壮性，防止对空指针进行无意义的操作==。

## void指针

- void在函数定义中表示**函数没有返回值或者没有形式参数**
	- `void *`是一个有效指针，==在后续使用中一般要进行强制类型转换==
	- 如动态内存分配函数`malloc()`的返回值就是`void *`类型，使用时要进行强制转换
```c
#include <stdio.h>

int main(){
    //分配可以保存30个字符的内存，并把返回的指针转换为 char *
    char *str = (char *)malloc(sizeof(char) * 30);
    gets(str);
    printf("%s\n", str);
    return 0;
}
```

# 9.11 数组和指针绝不等价，数组是另外一种类型

如下：

```c
#include <stdio.h>

int main(){
    int a[6] = {0, 1, 2, 3, 4, 5};
    int *p = a;
    int len_a = sizeof(a) / sizeof(int);
    int len_p = sizeof(p) / sizeof(int);
    printf("len_a = %d, len_p = %d\n", len_a, len_p);
    return 0;
}
```

- 其中，数组`a`的类型是`int[6]`，表示这是一个拥有6个`int`数据的集合


# 9.12 数组到底在什么时候会转换为指针

- C语言标准规定：
	- 当数组名**作为数组定义的标识符（即定义或声明数组时）**、**sizeof或&的操作数**时，才表示数组本身。其他表达式中，数组名会被转换为**指向第0个元素的指针**（地址）。
## 数组下标 `[]`

- C语言标准规定：
	- 数组下标和指针偏移量相同
	- 即，对数组下标的引用总是可以写成“一个指向数组的起始地址的指针加上偏移量”
- **对数组的引用 `a[i]` 在编译的时候总是会被编译器改写成 `*(a+i)` 的形式，C语言标准也要求编译器必须具备这种行为**
- 取下标操作符 `[]` 是建立在指针的基础上
	- 作用：**使一个指针和一个整数相加，产生一个新的指针，然后从这个指针指向的地址上取得数据**
- Tips：
	- `a[3]` 等价于 `*(a + 3)，3[a]` 等价于 `*(3 + a)`，仅仅是把加法的两个操作数调换了位置。

## 数组作为函数参数

- C语言标准：
	- 作为“类型的数组”的形参必须调整为“类型的指针”
	- 数组作为函数形参时，编译器必须要把数组形式改写成指向数组第0个元素的指针形式
	- 从而避免对整个数组的拷贝
- 这种隐式转换意味着下面三种形式的函数定义是完全等价的：
```c
void func(int *parr){ ...... }
void func(int arr[]){ ...... }
void func(int arr[5]){ ...... }
```

## 总结
1) 用 `a[i]` 这样的形式对数组进行访问**总是会被编译器改写**成（或者说解释为）像 `*(a+i)` 这样的指针形式。  
2) 指针始终是指针，它**绝不可以改写成数组**。你可以用下标形式访问数组，一般都是指针作为函数参数时，而且你知道**实际传递给函数的是一个数组**。  
3) 在特定的环境中，也就是数组作为函数形参，也只有这种情况，一个数组可以看做是一个指针。==作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针==。  
3) 当希望向函数传递数组时，可以把函数参数定义为数组形式（可以指定长度也可以不指定长度），也可以定义为指针。不管哪种形式，==在函数内部都要作为指针变量对待==。

# 9.13 C语言指针数组（数组每个元素都是指针）详解

- 如果一个数组中的所有元素保存的都是[指针](https://c.biancheng.net/c/80/)，那么我们就称它为指针数组。指针数组的定义形式一般为：
```c
dataType *arrayName[length];
```
- `[ ]`的优先级高于`*`，该定义形式应该理解为：
```c
dataType *(arrayName[length]);
```

- 指针数组还可以和字符串数组结合使用，请看下面的例子：
```c
1. #include <stdio.h>
2. int main(){
3.     char *str[3] = {
4.         "c.biancheng.net",
5.         "C语言中文网",
6.         "C Language"
7.     };
8.     printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
9.     return 0;
10. }
```
- 运行结果：  
```c
c.biancheng.net  
C语言中文网  
C Language  
```
  
- 需要注意的是，==字符数组 str 中存放的是字符串的首地址，不是字符串本身==，字符串本身位于其他的内存区域，和字符数组是分开的。  
- 也只有当指针数组中每个元素的类型都是`char *`时，才能像上面那样给指针数组赋值，其他类型不行。  
- 为了便于理解，可以将上面的字符串数组改成下面的形式，它们都是等价的。
```c
1. #include <stdio.h>
2. int main(){
3.     char *str0 = "c.biancheng.net";
4.     char *str1 = "C语言中文网";
5.     char *str2 = "C Language";
6.     char *str[3] = {str0, str1, str2};
7.     printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
8.     return 0;
9. }
```

# [一道题目玩转指针数组和二级指针](https://c.biancheng.net/view/vip_2021.html)


# 9.15 C语言二维数组指针（指向二维数组的指针）详解

[二维数组](https://c.biancheng.net/c/array/)在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。以下面的二维数组 a 为例：

```c
int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
```

从概念上理解，a 的分布像一个矩阵：

```c
0   1   2   3
4   5   6   7
8   9  10  11
```

但在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存：  
![二维数组在内存中的存储](https://c.biancheng.net/uploads/allimg/190117/16011C417-0.jpg)

C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。

假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示：  
![把二维数组拆解成一维数组](https://c.biancheng.net/uploads/allimg/190117/1601164D5-1.png)

```c
int (*p)[4] = a; // 指向a的二维指针变量p
// int *p[4] // 这种是数组指针，而不是指针变量，[]的优先级比*更高
```

1) `p`指向数组 a 的开头，也即第 0 行；`p+1`前进一行，指向第 1 行。
2) `*(p+1)`表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素
3) `*(p+1)+1`表示第 1 行第 1 个元素的地址
4) `*(*(p+1)+1)`表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据

## 指针数组和二维数组指针的区别

指针数组和二维数组指针在定义时非常相似，只是括号的位置不同：

```c
1. int *(p1[5]);  //指针数组，可以去掉括号直接写作 int *p1[5];
2. int (*p2)[5];  //二维数组指针，不能去掉括号
```

指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存

**个人理解：`*(p1[5])` 中`*`修饰的是`p1[5]`表是的是这个数组中存储的变量为指针；而 `(*p2)[5]`中`*`修饰的是`p2`，是一个指针变量，`[5]`表示“打包”5个这种指针变量，每一个指针变量都存储一行数据**

# 9.16 C语言函数指针（指向函数的指针）详解

**一个函数总是占用一段连续的内存区域**，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个[指针](https://c.biancheng.net/c/80/)变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。

函数指针的定义形式为：

```c
returnType (*pointerName)(param list);
```

- returnType 为函数返回值类型，pointerName 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也**可以只给出参数的类型，省略参数的名称**，这一点和函数原型非常类似。

- 注意`( )`的优先级高于`*`，第一个括号不能省略，如果写作`returnType *pointerName(param list);`就成了函数原型，它表明函数的返回值类型为`returnType *`。


```c
// 定义函数指针
int (*pmax)(int, int) = max; //也可以写作int (*pmax)(int a, int b)

// 利用函数指针调用函数
maxval = (*pmax)(x, y);
```

# 9.17 攻克C语言指针

[指针数组](https://c.biancheng.net/view/2020.html)、[二维数组指针](https://c.biancheng.net/view/2022.html)、[函数指针](https://c.biancheng.net/view/2023.html)等几种较为复杂的指针，它们的定义形式分别是：

```c
1. int *p1[6];  //指针数组
2. int *(p2[6]);  //指针数组，和上面的形式等价
3. int (*p3)[6];  //二维数组指针
4. int (*p4)(int, int);  //函数指针
```

C语言标准规定，==对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析==。

1) `int *p1[6];`

从 p1 开始理解，它的左边是 `*`，右边是 `[ ]`，`[ ]` 的优先级高于 `*`，所以编译器先解析`p1[6]`，p1 首先是一个拥有 6 个元素的数组，然后再解析`int *`，它用来说明数组元素的类型。从整体上讲，p1 是一个拥有 6 个 `int *` 元素的数组，也即指针数组。

2) `int (*p3)[6];`

从 p3 开始理解，( ) 的优先级最高，编译器先解析`(*p3)`，p3 首先是一个指针，剩下的`int [6]`是 p3 指向的数据的类型，它是一个拥有 6 个元素的一维数组。从整体上讲，p3 是一个指向拥有 6 个 int 元素数组的指针，也即二维数组指针。

> 为了能够通过指针来遍历数组元素，在**定义数组指针时需要进行降维处理**，例如三维数组指针实际指向的数据类型是二维数组，二维数组指针实际指向的数据类型是一维数组，一维数组指针实际指向的是一个基本类型；在表达式中，数组名也会进行同样的转换（下降一维）。

3) `int (*p4)(int, int);`

从 `p4` 开始理解，`( )` 的优先级最高，编译器先解析`(*p4)`，`p4` 首先是一个指针，它后边的 `( )` 说明 `p4` 指向的是一个函数，括号中的`int, int`是参数列表，开头的`int`用来说明函数的返回值类型。整体来看，`p4` 是一个指向原型为`int func(int, int);`的函数的指针。

[# 剩下几个分析看网址](https://c.biancheng.net/view/vip_2024.html)

# 9.18 main()函数的高级用法：接收用户输入的数据

[# main()函数的高级用法：接收用户输入的数据](https://c.biancheng.net/view/vip_2025.html)

一个具体的例子：

```c
1. #include <stdio.h>
2. int main(int argc, char *argv[]){
3.     int i;
4.     printf("The program receives %d parameters:\n", argc);
5.     for(i=0; i<argc; i++){
6.         printf("%s\n", argv[i]);
7.     }
8.     return 0;
9. }
```

将生成后的程序放在`D:\demo`目录下，命名为`main.exe`，打开 cmd（命令提示符程序），输入`D:\demo\main.exe C语言中文网 c.biancheng.net C-Lang`，程序的运行结果如下：  
![](https://c.biancheng.net/uploads/allimg/190117/1606242K6-0.png)  
从运行结果可以看出，包括程序名以及它后面的字符串都会被程序所接收。

# 9.19 对C语言指针的总结

[指针](https://c.biancheng.net/c/80/)（Pointer）就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本类型数据的地址，也可以存放数组、函数以及其他指针变量的地址。  
  
程序在运行过程中需要的是数据和指令的地址，变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符：在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址；程序被编译和链接后，这些名字都会消失，取而代之的是它们对应的地址。  
  

|   |   |
|---|---|
常见指针变量的定义

| 定  义         | 含  义                                                                |
| -------------- | --------------------------------------------------------------------- |
| `int *p;`      | `p` 可以指向 `int` 类型的数据，也可以指向类似 `int arr[n]` 的数组。   |
| `int **p;`     | `p` 为二级指针，指向 `int *` 类型的数据。                             |
| `int *p[n];`   | `p` 为指针数组。`[ ]` 的优先级高于 `*`，所以应该理解为 `int *(p[n]);` |
| `int (*p)[n];` | `p` 为[二维数组](https://c.biancheng.net/c/array/)指针。              |
| `int *p();`    | `p` 是一个函数，它的返回值类型为 `int *`。                            |
| `int (*p)();`  | `p` 是一个函数指针，指向原型为 `int func()` 的函数。                  |

  
1) 指针变量可以进行加减运算，例如`p++`、`p+i`、`p-=i`。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。  
  
2) 给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如`int *p = 1000;`是没有意义的，使用过程中一般会导致程序崩溃。  
  
3) 使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值`NULL`。  
  
4) 两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。  
  
5) 数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 sizeof、& 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针。
