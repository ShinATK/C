#编程基础  #c语言中文网 #c语言教程 

# 11.1 C语言typedef的用法详解

起别名的目的不是为了提高程序运行效率，而是为了编码方便。例如有一个结构体的名字是 stu，要想定义一个结构体变量就得这样写：

```c
struct stu stu1;
```

struct 看起来就是多余的，但不写又会报错。如果为 struct stu 起了一个别名 STU，书写起来就简单了：

```c
STU stu1;
```

这种写法更加简练，意义也非常明确，不管是在标准头文件中还是以后的编程实践中，都会大量使用这种别名。

**使用关键字 typedef 可以为类型起一个新的别名**

typedef 的用法一般为：

```c
typedef  oldName  newName;
```

oldName 是类型原来的名字，newName 是类型新的名字。例如：
```c
1. typedef int INTEGER;
2. INTEGER a, b;
3. a = 1;
4. b = 2;
```

`INTEGER a, b;`等效于`int a, b;`。

```c
typedef char ARRAY20[20];
ARRAY20 a1, a2, s1, s2;

// 等价于
char a1[20], a2[20], s1[20], s2[20];
```
- 注意，数组也是有类型的
	- `char a1[20];`定义了一个数组 a1，它的类型就是 char [20]

- 需要强调的是，==typedef 是赋予现有类型一个新的名字，而不是创建新的类型==。为了“见名知意”，==请尽量使用含义明确的标识符，并且尽量大写==

## `typedef` 和 `#define` 的区别

1) 可以使用其他类型说明符==对宏类型名进行扩展==，但对 typedef 所定义的类型名却不能这样做。如下所示：

```c
#define INTERGE int  
unsigned INTERGE n;  //没问题  
  
typedef int INTERGE;  
unsigned INTERGE n;  //错误，不能在 INTERGE 前面添加 unsigned
```

  
2) 在连续定义几个变量的时候，`typedef` 能够保证定义的所有变量均为同一类型，而 `#define` 则无法保证。例如：

```c
#define PTR_INT int *  
PTR_INT p1, p2;
```

经过宏替换以后，第二行变为：

```c
int *p1, p2;
```

这使得 p1、p2 成为不同的类型：p1 是指向 int 类型的指针，p2 是 int 类型。  
  
相反，在下面的代码中：

```c
typedef int * PTR_INT  
PTR_INT p1, p2;
```

p1、p2 类型相同，它们都是指向 int 类型的指针。

# 11.2 C语言const的用法详解，C语言常量定义详解

利用const关键字对变量进行固定，格式为：

```c
const type name=value；
```

## const 和[指针](https://c.biancheng.net/c/80/)

- const可以修饰指针，一般有以下几种形式：
	```c
	const int *p1; // 指向的地址可以修改，指针指向的地址的数据是只读的
	int const *p2; // 指向的地址可以修改，指针指向的地址的数据是只读的
	int * const p3; // 指针本身不能被改变
	```

- 指针与指向数据都是只读的写法：
	```c
	const int * const p4;
	int const * const p5;
	```

- **const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。**

## const 和函数形参

- const 通常用在函数形参中，如果形参是一个指针，**为了防止在函数内部修改指针指向的数据**，就可以用 const 来限制。

- 在C语言标准库中，有很多函数的形参都被 const 限制了，下面是部分函数的原型：
	```c
	size_t strlen ( const char * str );
	int strcmp ( const char * str1, const char * str2 );
	char * strcat ( char * destination, const char * source );
	char * strcpy ( char * destination, const char * source );
	int system (const char* command);
	int puts ( const char * str );
	int printf ( const char * format, ... );
	```

## const 和非 const 类型转换

- `const char *`和`char *`是不同的类型
	- 不能将`const char *`类型的数据赋值给`char *`类型的变量。
	- 但反过来是可以的，编译器允许将`char *`类型的数据赋值给`const char *`类型的变量。

# 11.3 C语言随机数生成教程，C语言rand和srand用法详解

在C语言中，我们一般使用 `<stdlib.h>` 头文件中的 `rand()` 函数来生成随机数，它的用法为：

```c
// 随机生成一个位于 0 ~ RAND_MAX 之间的整数。
int rand (void); // void表示不需要传递参数
```

- `RAND_MAX` 是 `<stdlib.h>` 头文件中的一个宏，它用来指明 `rand()` 所能返回的随机数的最大值

## 随机数的本质

实际上，rand() 函数产生的随机数是**伪随机数**，是根据一个数值按照某个公式推算出来的，这个数值我们称之为“种子”。种子和随机数之间的关系是一种正态分布，如下图所示：  
  

![C语言随机数和种子之间呈正态分布](https://c.biancheng.net/uploads/allimg/190118/1-1Z11QAT9315.gif)

  
种子在每次启动计算机时是随机的，但是一旦计算机启动以后它就不再变化了；也就是说，每次启动计算机以后，种子就是定值了，所以根据公式推算出来的结果（也就是生成的随机数）就是固定的。

## 重新播种

通过 `srand()` 函数来重新“播种”，这样种子就会发生改变。`srand()` 的用法为：

```c
void srand (unsigned int seed);
```

- 它需要一个 `unsigned int` 类型的参数。在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同。

使用 <time.h> 头文件中的 time() 函数即可得到当前的时间（精确到秒），就像下面这样：  

```c
srand((unsigned)time(NULL));
```
- [time()函数](https://cplusplus.com/reference/ctime/time/)

## 生成一定范围内的随机数

- 可以利用取模的方法：

```c
int a = rand() % 10;    //产生0~9的随机数，注意10会被整除

// 规定上下限
int a = rand() % 51 + 13; // 产生13~63的随机数
```

- 分析：取模即取余，`rand()%51+13`我们可以看成两部分：`rand()%51`是产生 0~50 的随机数，后面`+13`保证 a 最小只能是 13，最大就是 50+13=63。


