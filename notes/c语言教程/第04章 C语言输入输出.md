#编程基础  #c语言中文网 #c语言教程  
# 4.3 使用scanf读取从键盘上输入的数据

C语言中三个可以在显示器上输出数据的函数：

- puts()
- putchar()
- printf()

| 格式控制符                      | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| %c                              | 输出一个单一的字符                                           |
| %hd、%d、%ld                    | 以十进制、有符号的形式输出 short、int、long 类型的整数       |
| %hu、%u、%lu                    | 以十进制、无符号的形式输出 short、int、long 类型的整数       |
| %ho、%o、%lo                    | 以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数 |
| %#ho、%#o、%#lo                 | 以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数 |
| %hx、%x、%lx %hX、%X、%lX       | 以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。 |
| %#hx、%#x、%#lx %#hX、%#X、%#lX | 以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。 |
| %f、%lf                         | 以十进制的形式输出 float、double 类型的小数                  |
| %e、%le %E、%lE                 | 以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。 |
| %g、%lg %G、%lG                 | 以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。 |
| %s                              | 输出一个字符串                                               |

**printf()的高级用法**：

- 格式控制符：`%[flag][width][.precision]type`

  表示此处的内容可有可无，是可以省略的。

- width：表示最小输出宽度，不足时空格补齐，超过时按数据本身长度输出

- .precision：表示输出精度

  - 会四舍五入，位数不足时补0
  - 对字符串使用时，表示最大输出宽度，会截取字符串

| 标志字符 | 含  义                                                       |
| -------- | ------------------------------------------------------------ |
| -        | `-`表示左对齐。如果没有，就按照默认的对齐方式，默认一般为右对齐。 |
| +        | 用于整数或者小数，表示输出符号（正负号）。如果没有，那么只有负数才会输出符号。 |
| 空格     | 用于整数或者小数，输出值为正时冠以空格，为负时冠以负号。     |
| #        | 对于八进制（%o）和十六进制（%x / %X）整数，# 表示在输出时添加前缀；八进制的前缀是 0，十六进制的前缀是 0x / 0X。对于小数（%f / %e / %g），# 表示强迫输出小数点。如果没有小数部分，默认是不输出小数点的，加上 # 以后，即使没有小数部分也会带上小数点。 |

- **printf()不能立即输出的问题**（linux和macos上）

```c
#include<stdio.h>
#include<unistd.h>
int main()
{
    printf("C语言中文网");
    sleep(5);  //程序暂停5秒钟
    printf("http://c.biancheng.net\n");

    return 0;
}
```

- 此时运行会发生第一个printf暂停五秒后和第二个printf一同输出
  - 当给第一个printf中加入换行符`\n`后，问题解决
  - 原因：**输出缓冲区/缓存**。printf执行结束后，数据并不会直接输出到显示器上，而是存放在缓冲区，直到遇到换行符`\n`才将缓冲区的数据输出到显示器上
- 但是在windows下，第一个printf会正常输出
  - 原因：**windows和linux、macos的缓存机制不同**

# 4.4 从键盘输入字符和字符串

- 输入：
  - scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。
  - getchar()、getche()、getch()：这三个函数都用于输入单个字符。
  - gets()：获取一行数据，并作为字符串处理。

- **scanf()，注意输入数据格式要和控制字符串的格式保持一致**
  - 如：`scanf("%d %d", &c, &d);`这里的%d之间有空格，所以输入时候也要加空格（空格数目不需要一一对应）
  - 但是如果有逗号分隔输入同样要加逗号
  - 有的是`scanf('%d is bigger than %d', &c, &d);`
  - **本质上scanf()进行的是从用户输入的字符串中提取有效数据的过程**
  - 同样，键盘输入的值并没有直接传给scanf而是放入缓冲区，直到按下回车键，scanf才从缓冲区中读取，符合要求则读取结束，不符合要求则等待或读取失败
  - 读取字符串时，以空格分隔，遇到空格则认为当前字符串结束，所以无法读取含有空格的字符串
- **输入输出，需要配合缓冲区进行理解学习**
- 字符串的名字会自动转换为字符串的地址

- getchar()
  - `scanf("%c", c)`的替代品
- getche()
  - 没有缓冲区，立刻读取数据不需要回车
  - `conio.h`头文件中，windows特有
- getch()
  - 没有缓冲区
  - 不会显示输入的字符，即没有回显
  - 适合某些特殊情况下，不希望出现回显的时候，比如输入密码
  - 同样位于`conio.h`头文件中

- gets()
  - 可以读取空格，回车才会结束
- scanf能一次性读取多分类型相同或不同的数据，但其他几个都只能一次读取一份特定类型的数据

# 4.5 缓冲区/缓存，与输入输出有关的疑难杂症

缓冲区 buffer/缓存 cache，是内存控件的一部分

## 引入缓冲区/缓存的原因

- 让低速的输入设备和高速的用户程序能够协调工作，并降低输入设备的读写次数
  - 用户执行速度可以看作是cpu速度，排除硬件的影响，理论上认为二者同步
- 利用缓冲区，可以将数据先放入缓冲区中，提高与cpu之间的交互速率（远高于硬盘的速率）
- 降低硬件设备的读写速率
  - 程序->告知操作系统内核kernel->调用驱动程序->操作硬件
  - 从用户程序到硬件设备之间需要经过多次转换，这些转换的开销会很大，从而制约程序性能
  - 所以，此时分配缓冲区可以大大减少转换的次数，从而实现成倍提升程序性能的效果

## 缓冲区的类型

- 设备：
  - 输入缓冲区
    - Windows、Linux、Mac OS 在实现时都给输入设备带上了行缓冲，所以 scanf()、getchar()、gets() 在每个平台下的表现都一致。
    - 如果没有，当像输入整数789，当输入7时就会立刻读取，从而导致读取了错误的输入数据
    - 但某些时刻需要程序能立刻响应，例如游戏操作。windows下的getche和getch就是为了这种特殊需求而设计的
  - 输出缓冲区：对于输出设备来说缓冲区的影响不大
    - Windows 平台下，输出设备是不带缓冲区的；
    - Linux 和 Mac OS 平台下，输出设备带有行缓冲区。

- **数据刷新时机**：（重点）
  - 全缓冲：缓冲区被填满后才进行输入输出操作
    - 数据写入文件需要将文件关闭/关闭程序后才会写入文件中，因为之前一直存放在缓存区
  - 行缓冲
    - 输入输出遇到换行符才执行
    - 例如：标准输入输出设备，即键盘和显示器，就比如之前sleep5s第一个printf和第二个同时输出
  - 不带缓冲
    - 例如sleep5s的例子，windows下就可以正常输出第一个printf
    - 错误信息输出函数perror()没有缓冲区，因为错误信息必须马上显示出来
  - **缓冲区的刷新（清空）**：将缓冲区的内容送到目的地
    - 行缓冲和全缓冲，缓冲区满时就立刻刷新
    - 行缓冲遇到`\n`时刷新
    - 关闭文件会刷新
    - 程序关闭时一般也会（铜鼓标准库保障）
    - 使用特定函数手动刷新缓冲区

- 缓冲区位于用户程序和硬件设备之间，用来缓存数据，目的是让快速的 CPU 不必等待慢速的输入输出设备，同时减少操作硬件的次数。对于 IO 密集型的网络应用程序，比如网站、数据库、DNS、CDN 等，缓冲区的设计至关重要，它能十倍甚至一百倍得提高程序性能。

# 4.8 scanf的高级用法

利用正则表达式去匹配读取的字符

- `%{*} {width} type`控制字符串
  - {}表示可有可无
  - type表示读取数据的类型，如：`%d %s %[a-z] %[^\n]`等，必须有（`^`表示不匹配，连接符`-`来表示一个范围内的字符）
  - width表示最大读取宽度
  - *表示丢弃读取到的数据

# 4.9 C语言模拟密码输入（显示星号）

```c
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#define PWDLEN 20

void getpwd(char *pwd, int pwdlen);

int main(){
    char pwd[PWDLEN+1];
    printf("Input password: ");
    getpwd(pwd, PWDLEN);
    printf("The password is: %s\n", pwd);
    return 0;
}

/**
* 获取用户输入的密码
* @param  pwd     char*  保存密码的内存的首地址
* @param  pwdlen  int    密码的最大长度
**/
void getpwd(char *pwd, int pwdlen){
    char ch = 0;
    int i = 0;
    while(i<pwdlen){
        ch = getch();

        if(ch == '\r'){  //回车结束输入，不同字符输入函数，回车键产生的字符不同
            printf("\n");
            break;
        }
       
        if(ch=='\b' && i>0){  //按下删除键，无法直接删除数组中的元素，但是可以替换
            i--;
            printf("\b \b");
        }else if(isprint(ch)){  //输入可打印字符
            pwd[i] = ch;
            printf("*");
            i++;
        }
    }
    pwd[i] = 0;
}
```

# 4.10 C语言非阻塞式键盘监听，用户不输入数据程序也能继续执行

键盘监听：用户按下某个键时系统做出相应的处理

- 输入输出函数也是监听函数的一种

- 案例：

```c
#include <stdio.h>
#include <conio.h>
int main(){
    char ch;
    int i = 0;
    //循环监听，直到按Esc键退出
    while(ch = getch()){
        if(ch == 27){
            break;
        }else{
            printf("Number: %d\n", ++i);
        }
    }
    return 0;
}
```

- 通过getch监听键盘输入，但是每次都需要输入下一个键才能执行getch后边的代码，即**getch后边的代码被阻塞了**
- 对于某些游戏来说，这种阻塞式键盘监听会影响游戏操作。故一般采用非阻塞式监听：用户输入后可以捕获，不输入数据程序也可以继续执行
- windows系统中，`conio.h`头文件中的`kbhit()`函数实现非阻塞式监听
  - `kbhit()`不会返回数据，只是用于检测缓冲区中是否有数据，有则返回非0值，无则返回0，数据仍然留在缓冲区

```c
#include <stdio.h>
#include <windows.h>
#include <conio.h>
int main(){
    char ch;
    int i = 0;
    //循环监听，直到按Esc键退出
    while(1){
        if(kbhit()){  //检测缓冲区中是否有数据
            ch = getch();  //将缓冲区中的数据以字符的形式读出
            if(ch == 27){
                break;
            }
        }
        printf("Number: %d\n", ++i);
        Sleep(1000);  //暂停1秒
    }
    return 0;
}
```

