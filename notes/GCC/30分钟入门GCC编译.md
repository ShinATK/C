#编程基础 #gcc

- 查看gcc版本：
```shell
gcc -v
gcc --version
```
- gcc可以根据后缀名不同，自行判断源程序所使用的编程语言
	- 同时也可以使用 `-x` 来指明对应语言
	- 例如使用指明使用c语言编译器来编译demo文件
	- `gcc -xc demo`

# GCC常用的编译选项
| gcc/g++指令选项         | 功 能                                                                                                                                      |     |     |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | --- | --- |
| -E（大写）              | 预处理指定的源文件，不进行编译。                                                                                                           |     |     |
| -S（大写）              | 编译指定的源文件，但是不进行汇编。                                                                                                         |     |     |
| -c                      | 编译、汇编指定的源文件，但是不进行链接。                                                                                                   |     |     |
| -o                      | 指定生成文件的文件名。                                                                                                                     |     |     |
| -llibrary（-I library） | 其中 library 表示要搜索的库文件的名称。该选项用于手动指定链接环节中程序可以调用的库文件。建议 -l 和库文件名之间不使用空格，比如 -lstdc++。 |     |     |
| -ansi                   | 对于 C 语言程序来说，其等价于 -std=c90；对于 C++ 程序来说，其等价于 -std=c++98。                                                           |     |     |
| -std=                   | 手动指令编程语言所遵循的标准，例如 c89、c90、c++98、c++11 等。                                                                             |     |     |

- 如何将一个源代码程序经历预处理、编译、汇编以及链接这 4 个过程，最终生成对应的可执行程序
- GCC一次性执行四个过程生成可执行程序
	- 预处理（Preprocessing）
	- 编译（Compilation）
	- 汇编（Assembly）
	- 链接（Linking）
# GCC -E选项：对源程序做预处理操作

## 预处理的目的

- 主要是处理那些源文件和头文件中以 # 开头的命令（比如 `#include`、`#define`、`#ifdef` 等），并删除程序中所有的注释 `//` 和 `/* ... */`
- 默认情况下 gcc -E 指令只会将预处理操作的结果输出到屏幕上，并**不会自动保存到某个文件**。因此该指令往往会和 -o 选项连用，将结果导入到指令的文件中

```shell
gcc -E demo.c -o demo.i

# 这里大写的C，用来阻止删除头文件和源文件中的注释
gcc -E -C demo.c -o demo.i
```
## gcc -E的常用项

|选 项|功 能|
|---|---|
|`-D name[=definition]`|在处理源文件之前，先定义宏 name。宏 name 必须是在源文件和头文件中都没有被定义过的。将该选项搭配源代码中的#ifdef name命令使用，可以实现条件式编译。如果没有指定一个替换的值（即省略 =definition），该宏被定义为值 1。|
|`-U name`|如果在命令行或 GCC 默认设置中定义过宏 name，则“取消”name 的定义。-D 和 -U 选项会依据在命令行中出现的先后顺序进行处理。|
|`-include file`|如同在源代码中添加 `#include "file"` 一样。|
|`-iquote dir`|对于以引号（`#include ""`）导入的头文件中，-iquote 指令可以指定该头文件的搜索路径。当 GCC 在源程序所在目录下找不到此头文件时，就会去 -iquote 指令指定的目录中查找。|
|`-I dir`|同时适用于以引号 "" 和 <> 导入的头文件。当 GCC 在 -iquote 指令指定的目录下搜索头文件失败时，会再自动去 -I 指定的目录中查找。该选项在 GCC 10.1 版本中已被弃用，并建议用 -iquote 选项代替。|
|`-isystem dir  <br>-idirafter dir`|都用于指定搜索头文件的目录，适用于以引号 "" 和 <> 导入的头文件。|

# GCC -S选项：编译非汇编文件

## gcc -S指令

- 编译，程序构建的核心部分
	- 简单理解就是将预处理得到的程序代码，经过一系列的词法分析、语法分析、语义分析以及优化，加工为当前机器支持的汇编代码

```shell
gcc -E demo.c -o demo.i # 预处理
gcc -S demo.i # 编译
# 同样可以加 -o 来指定输出文件名
gcc -S demo.i -o test.i # 保存在 test.i 中
```

- 默认情况下，编译操作会自行新建一个文件名和指定文件相同、后缀名为 .s 的文件，并将编译的结果保存在该文件中
- **-S 选项的功能是令 GCC 编译器将指定文件处理至编译阶段结束**
	- 如果操作对象为 .i 文件，则 GCC 编译器*只需编译*此文件
	- 如果操作对象为 .c 或者 .cpp 源代码文件，则 GCC 编译器会对其进行*预处理*和*编译*这 2 步操作

```shell
# 利用 -fverbose-asm 选项给汇编代码添加必要的注释
gcc -S demo.c -fverbose-asm
```

# GCC -c选项：生成目标文件

- 汇编其实就是将汇编代码转换成可以执行的机器指令

- 将**指定文件**加工至汇编阶段，并生成相应的目标文件
	- 指定文件为**源程序文件**（例如 demo.c），则 gcc -c 指令会对 demo.c 文件执行预处理、编译以及汇编这 3 步操作；
	- 指定文件为刚刚经过**预处理后的文件**（例如 demo.i），则 gcc -c 指令对 demo.i 文件执行编译和汇编这 2 步操作；
	- 指定文件为刚刚经过**编译后的文件**（例如 demo.s），则 gcc -c 指令只对 demo.s 文件执行汇编这 1 步操作
	- 会根据所给文件的后缀名 .o，自行判断出此类文件为目标文件，仅需要进行链接操作

```shell
gcc -c demo.s
gcc -c demo.s -o demo.o
ls
# demo.c  demo.i  demo.o  demo.s
```

- 得到生成目标文件之后，接下来就可以直接使用 gcc 指令继续执行链接操作

```shell
gcc demo.o -o demo.exe  
```

# GCC -o选项：指定输出文件

- gcc -o 指令的使用语法格式

```shell
gcc [-E|-S|-c] [infile] [-o outfile]
```

## GCC -o选项使用举例

1) 将源文件作为输入文件，将可执行文件作为输出文件，也即完整地编译整个程序：

```shell
gcc main.c func.c -o app.out
```

将 main.c 和 func.c **两个源文件编译成一个可执行文件**，其名字为 app.out。如果不使用 -o 选项，那么将生成名字为 a.out 的可执行文件。  
  
2) 将源文件作为输入文件，将目标文件作为输出文件，也即只编译不链接：

```shell
gcc -c main.c -o a.o
```

将源文件 main.c 编译为目标文件 a.o。如果不使用 -o 选项，那么将生成名为 main.o 的目标文件。  
  
3) 将源文件作为输入文件，将预处理文件作为输出文件，也即只进行预处理操作：

```shell
gcc -E main.c -o demo.i
```

对源文件 main.c 进行预处理操作，并将结果放在 demo.i 文件中。如果不使用 -o 选项，那么将生成名为 main.i 的预处理文件。  
  
4) 将目标文件作为输入文件，将可执行文件作为输出文件：

```shell
gcc -c func.c main.c  
gcc func.o main.o -o app.out
```

第一条命令只编译不链接，将生成 func.o 和 main.o 两个目标文件。第二条命令将生成的两个目标文件生成最终的可执行文件 app.out。如果不使用 -o 选项，那么将生成名字为 a.out 的可执行文件。

# GCC -l选项：手动添加链接库

链接器把多个二进制的目标文件（object file）链接成一个单独的可执行文件。在链接过程中，它必须把符号（变量名、函数名等一些列标识符）用对应的数据的内存地址（变量地址、函数地址等）替代，以完成程序中多个模块的外部引用。

# GCC分步编译C++程序（汇总版）

- 可以添加 -save-temps 得到中间步骤文件
```shell
g++ demo.cpp -save-temps
ls
# a.out  demo.c  demo.cpp  demo.ii  demo.o  demo.s
```

# GCC指令一次处理多个文件

- 拥有 2 个源文件的 C 语言项目：

```shell
ls  
# main.c  myfun.c  
gcc -c myfun.c main.c  # 编译目标文件
ls  
# main.c  main.o  myfun.c  myfun.o  
gcc myfun.o main.o -o main.exe  # 生成可执行文件
ls  
# main.c  main.exe  main.o  myfun.c  myfun.o  
./main.exe  
# GCC:http://c.biancheng.net/gcc/
```

- gcc 指令还可以直接编译并链接它们

```shell
gcc -c myfun.c main.c -o main.exe
```

- 如果有大量的文件，可以进入该项目目录，用 `*.c` 表示所有的源文件，即执行如下指令

```shell
ls
# main.c  myfun.c ....
gcc -c *.c -o main.exe
ls  
# main.c  main.exe  myfun.c ....
```

# GCC使用静态链接库和动态链接库 

- 头文件和库文件并不是一码事，它们最大的区别在于：
	- **头文件**只存储变量、函数或者类等这些功能模块的**声明部分**，
	- **库文件**才负责存储各模块**具体的实现部分**。
- 库文件是无法直接使用的，只能通过头文件间接调用 

> 头文件和库文件相结合的访问机制，最大的好处在于，有时候我们只想让别人使用自己实现的功能，并不想公开实现功能的源码，就可以将其制作为库文件，这样用户获取到的是二进制文件，而头文件又只包含声明部分，这样就实现了“将源码隐藏起来”的目的，且不会影响用户使用。关于如何制作库文件，后续章节会做详细讲解。

## 静态链接库

- 实现方式：
	- GCC 编译器直接将该模板代码直接复制到程序文件的适当位置，最终生成可执行文件
- 优势：
	- 生成的可执行文件不再需要任何静态库文件的支持就可以独立运行（**可移植性强**）
- 劣势：
	- 如果程序文件中多次调用库中的同一功能模块，则该模块代码势必就会被复制多次，生成的可执行文件中会包含多段完全相同的代码，造成**代码的冗余**

> 在 Linux 发行版系统中，静态链接库文件的后缀名通常用 .a 表示；在 Windows 系统中，静态链接库文件的后缀名为 .lib

## 动态链接库

- 实现方式：
	- 将功能模块的位置信息记录到文件中，直接生成可执行文件
- 优势
	- 由于可执行文件中记录的是**功能模块的地址**，真正的实现代码会在程序运行时被载入内存，这意味着，**即便功能模块被调用多次，使用的都是同一份实现代码**（这也是将动态链接库称为共享链接库的原因）。
- 劣势
	- 此方式生成的可执行文件**无法独立运行**，必须借助相应的库文件（**可移植性差**）

> 在 Linux 发行版系统中，动态链接库的后缀名通常用 .so 表示；在 Windows 系统中，动态链接库的后缀名为 .dll

# 用GCC制作静态链接库

- 如果仅希望别人使用我们实现的功能，但又不想它看到具体实现的源码，该怎么办呢？
	- 创建静态链接库

## 静态链接库的创建

- 能被创建为静态链接库的要求
	- 源文件中**只提供可以重复使用的代码**，例如函数、设计好的类等，不能包含 main 主函数；
	- 源文件在实现具备模块功能的同时，还**要提供访问它的接口**，也就是**包含各个功能模块声明部分的头文件**

将源文件打包为静态链接库的过程很简单，只需经历以下 2 个步骤：  

1) 将所有指定的源文件，都编译成相应的目标文件：

```shell
gcc -c sub.c add.c div.c  
ls  
# add.c  add.o  div.c  div.o  main.c  sub.c  sub.o  test.h
```

2) 然后使用 ar 压缩指令，将生成的目标文件打包成静态链接库，其基本格式如下：

```shell
ar rcs 静态链接库名称 目标文件1 目标文件2 ...
```

- 静态链接库的命名规则：
	- `libxxx.a`
	- Linux 系统下，静态链接库的后缀名为 .a
	- Windows 系统下，静态链接库的后缀名为 .lib

```shell
ar rcs libmymath.a add.o sub.o div.o  
ls  
# add.c  add.o  div.c  div.o  libmymath.a  main.c  sub.c  sub.o  test.h
```

## 静态链接库的使用

1) 先将 main.c 文件编译为目标文件

	```shell
	gcc -c main.c
	```

2) 实现链接操作
	- `-static`：强制使用静态链接库
	```shell
	gcc -static main.o libmymath.a
	```
	- 如果无法找到静态链接库
	```shell
	gcc main.o -static -L /root/demo/ -lmymath
	```
	- -L（大写的 L）选项用于向 GCC 编译器指明静态链接库的存储位置（可以借助 pwd 指令查看具体的存储位置）
	- -l（小写的 L）选项用于指明所需静态链接库的名称，注意这里的名称指的是 xxx 部分，且建议将 -l 和 xxx 直接连用（即 -lxxx），中间不需有空格

# 用GCC制作动态链接库

## 动态链接库的创建

- 两种方式

1) 直接使用源文件创建动态链接库，采用 gcc 命令实现的基本格式如下：

```shell
gcc -fpic -shared 源文件名... -o 动态链接库名
```

- 其中，
	- -shared 选项用于生成动态链接库；
	- -fpic（还可写成 -fPIC）选项的功能是，
		- 令 GCC 编译器生成动态链接库（多个目标文件的压缩包）时，表示各目标文件中函数、类等功能模块的地址使用相对地址，而非绝对地址。这样，无论将来链接库被加载到内存的什么位置，都可以正常使用。  
  
例如，由 demo 项目中的 add.c、sub.c 和 div.c 这 3 个源文件生成一个动态链接库，执行命令为：  

```shell
ls  
# add.c  div.c  main.c  sub.c  test.h  
gcc -fpic -shared add.c sub.c div.c -o libmymath.so  
ls  
# add.c  div.c  libmymath.so  main.c  sub.c  test.h
```

> 注意，动态链接库的命令规则和静态链接库完全相同，只不过在 Linux 发行版系统中，其后缀名用 .so 表示；Windows 系统中，后缀名为 .dll。

2) 先使用 gcc -c 指令将指定源文件编译为目标文件

```shell
ls  
# add.c  div.c  main.c  sub.c  test.h  
gcc -c -fpic add.c sub.c div.c  
ls  
# add.c  add.o  div.c  div.o  main.c  sub.c  sub.o  test.h
```

注意，为了后续生成动态链接库并能正常使用，将源文件编译为目标文件时，也需要使用 -fpic 选项。  
  
在此基础上，接下来利用上一步生成的目标文件，生成动态链接库：  

```shell
gcc -shared add.o sub.o div.o -o libmymath.so  
ls  
# add.c  add.o  div.c  div.o  libmymath.so  main.c  sub.c  sub.o  test.h
```

## 动态链接库的使用

- 借助动态链接库成功生成可执行文件

```shell
gcc main.c  libmymath.so -o main.exe  
ls  
# add.c  div.c  libmymath.so  main.c  main.exe  sub.c  test.h
```

但此时的执行文件无法直接执行，提示找不到动态链接库

- 通过执行`ldd main.exe`指令，可以查看当前文件在执行时需要用到的所有动态链接库，以及各个库文件的存储位置

```shell
ldd main.exe  
# linux-vdso.so.1 =>  (0x00007fff423ff000)  
# libmymath.so => not found  
# libc.so.6 => /lib64/libc.so.6 (0x00000037e2c00000)  
# /lib64/ld-linux-x86-64.so.2 (0x00000037e2800000)
```

- 运行由动态链接库生成的可执行文件时，必须确保程序在运行时可以找到这个动态链接库。常用的解决方案有如下几种：
	- 将链接库文件移动到标准库目录下（例如 /usr/lib、/usr/lib64、/lib、/lib64）；
	- 在终端输入`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx`，其中 xxx 为动态链接库文件的绝对存储路径（此方式**仅在当前终端有效，关闭终端后无效**）；
	- 修改~/.bashrc 或~/.bash_profile 文件，即在文件最后一行添加`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx`（xxx 为动态库文件的绝对存储路径）。保存之后，执行`source .bashrc`指令（此方式仅对当前登陆用户有效）。

# 显示调用C/C++动态链接库

如何创建一个动态链接库，以及如何使用它完成程序的链接和运行。但需要指明的是，这只是动态链接库的其中一种用法，本节将讲解它的另外一种用法

动态链接库的调用方式有 2 种，分别是：

- 隐式调用（静态调用）：将动态链接库和其它源程序文件（或者目标文件）一起参与链接；
- 显式调用（动态调用）：手动调用动态链接库中包含的资源，同时用完后**要手动将资源释放**。

# GCC找不到库文件怎么办？



